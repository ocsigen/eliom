<<div class='leftcol'|<<leftcoldoc version="dev">>>>
      <<div class="colprincipale"|
        ==4. Using Eliom client side

//Warning: Features presented here are experimental.
We have been working on them for more than two years and
they will be released very soon.
Use it if you want to test,
but syntax and interfaces will change a lot during the next weeks,
as we are currently working on simplifying the syntax and
uniformizing server and client sides.//

//The manual is very basic for now.
Turn back in a few days for a more complete manual!//

This part of the manuel describes how to use Eliom for mixing client side
and server side programming.
Eliom allows to write the client and server parts of a Web application
fully in Objectice Caml.
Running OCaml in the client's browser is acheived by compiling OCaml bytecode
into Javascript. Check the [[wiki(30):/|js_of_ocaml]] project for news and
information.


===@@id="p4basics"@@

====Your first client-server application
        <<div class="onecol"|

First, I need to create my Eliom application, by applying the functor
{{{Eliom_predefmod.Eliom_appl}}}. You can define here what will be
the default title for pages belonging to this application, the
default container for pages, the default stylesheets you want for your
whole application.

<<code language="ocaml" |
(* for client side only, one can use : {client{ ... }} and for shared code, one
* can place {shared{ ... }} *)
{shared{
open XHTML5.M
}}
{client{
open Eliom_client.Sp (* On client side, sp is a global variable defined in
                        this module. *)
}}

(****** server only *******)
{server{ (* note that {server{ ... }} is optionnal. *)
open Eliom_parameters
open Eliom_predefmod.Xhtml5compact
open Eliom_services
}}

(* This is server only because there are no delimiters. *)
module Eliom_appl =
  Eliom_predefmod.Eliom_appl (
    struct
      let application_name = "testsuite_eliom2"
      let params =
        {Eliom_predefmod.default_appl_params with
           Eliom_predefmod.ap_title = "Eliom application example";
           Eliom_predefmod.ap_headers_before =
            [XHTML5.M.style
               [XHTML5.M.pcdata "a,.clickable {color: #111188; cursor: pointer;}"]];
           Eliom_predefmod.ap_container =
            Some (None,
                  fun ~sp div ->
                    [h1 [pcdata "Eliom application"];
                     p [pcdata "Random value in the container: ";
                        pcdata (string_of_int (Random.int 1000))];
                     div ])
        }
    end)
>> Now I can define my first service belonging to that application: <<code language="ocaml" |

let eliomclient1 =
  Eliom_appl.register_service
    ~path:["eliomclient1"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[
                        (* with {{ expr }}, the expression is executed by the client. *)
                        a_onclick {{Dom_html.window##alert(Js.string "clicked!") ; Lwt.return ()}}]
           [pcdata "I am a clickable paragraph"];

        ])
>>
All services belonging to the application will be entry points to the
application. It means that if you call such a service, the client side
code will be sent to the browser, and the client side execution will
start, //and will not stop if you go to another service belonging to
the same application!//

====Compiling
//soon (have a look at Ocsigen source for now -- //examples// directory)//

====Using a distant Eliom service in client side code

For now, the syntax extension has not been implemented, thus the syntax
is somewhat more complicated. Here are some examples of what you can do:
<<code language="ocaml" |
let eliomclient2 = service ~path:["eliomclient2"] ~get_params:unit ()

let myblockservice =
  Eliom_predefmod.Blocks5.register_post_coservice
    ~fallback:eliomclient2
    ~post_params:unit
    (fun _ () () ->
       Lwt.return
         [p [pcdata ("I come from a distant service! Here is a random value: "^
                       string_of_int (Random.int 100))]])

;; (* This ";;" is necessary in order to have the "shared" following entry being
      parsed as "str_item" (instead of "expr"). This is Camlp4 related, it may
      evolve.
    *)

{shared{
let item () = li [pcdata Sys.ocaml_version]
}} ;;

let _ =
  Eliom_appl.register
    eliomclient2
    (fun sp () () ->
      Lwt.return
        [
>>
  The following example shows how to go to another service,
  exactly like pressing a link (here a service that do not belong to
  the application):
<<code language="ocaml" |
          p
            ~a:[
              a_onclick
                {{Eliom_client.exit_to
                    ~sp
                    ~service:\(Tutoeliom.coucou) (* just as [coucou] *)
                    () ()
                }}
            ]
            [pcdata "Click here to go to another page."];

>>
To use server values inside client code one should use the syntax {{{ \(e) }}}
where {{{k}}} is the wrapper keyword and {{{e}}} the sent expression. Note that
{{{e}}} is evaluated by the server and the resulting value is send to the
client at loading time.
<<code language="ocaml" |


              a_onclick
                ((fun.client
                    (sp : Eliom_client_types.server_params Eliom_client_types.data_key)
                    (myblockservice : (unit, unit, 'c, 'd, 'e, 'f, 'g, Eliom_services.http) Eliom_services.service) ->
                      let sp = Eliommod_client.unwrap_sp sp in
                      let body = Dom_html.document##body in
                      (*Js_old.get_element_by_id "bodyid"*)
                      Eliom_client.call_service
                        ~sp ~service:myblockservice () () ~>>= fun s ->
                      (try
                         let l = Js_old.Node.children (Js_old.dom_of_xml s) in
                         List.iter (Js_old.Node.append body) l
                       with e -> Js_old.alert (Printexc.to_string e));
(* does not work with chrome. A solution is probably to use set "innerHTML". *)
                       Lwt.return ()
                 ) (Eliom_client.wrap_sp sp) myblockservice)
            ]
            [pcdata "Click here to add content from the server."];
 *)
(* 
*zap*)

>>
  The following examples shows how to change the URL.
  This is a low level function and is usually not to be used directly.
  As browsers do not not allow to change the URL,
  we write the new URL in the fragment part of the URL.
  A script must do the redirection if there is something in the fragment
  while the page is loading.
<<code language="ocaml" |
          p
            ~a:[
              a_onclick {{
                Eliom_client.change_url ~sp
                  ~service:\(Tutoeliom.coucou)
                  () ()
              }}
            ]
            [pcdata "Click here to change the URL."];

>>
  The following examples shows how to change the current page,
  without stopping the client side program.
<<code language="ocaml" |
          p
            ~a:[
              a_onclick
                {{Eliom_client.change_page ~sp
                    ~service:\(eliomclient1)
                    () ()
                }}
            ]
            [pcdata "Click here to change the page without stopping the program."];

>> Actually the usual {{{a}}} function to create link will
  use {{{change_page}}} if you do a link inside the same application.
  The latter example is equivalent to the following. <<code language="ocaml" |
          p [a 
               ~sp
               ~service:eliomclient1
               [pcdata "Click here to change the page without stopping the program (with ";
                code [pcdata "a"];
                pcdata ")."]
               ()];
          p
            ~a:[
              a_onclick{{
                Eliom_client.change_page ~sp ~service:\(Tutoeliom.coucou)
                  () ()
              }}
            ]
            [pcdata "Click here to go to a page outside the application, using ";
             code [pcdata "change_page"];
             pcdata "."];
          p
            ~a:[
              a_onclick {{
                Eliom_client.exit_to ~sp ~service:\(eliomclient2) () ()
              }}
            ]
            [pcdata "Click here to relaunch the program by reloading the page."];
          p
            ~a:[
              a_onclick {{
                Eliom_client.change_page ~sp ~service:\(eliomclient1)
                  () ()
              }}
            ]
            [pcdata "A generic client-side function for calling ";
             code [pcdata "change_page"];
             pcdata "."];

>>
  The following examples shows how to get a subpage from the server,
  and put it inside your page.
<<code language="ocaml" |
          p
            ~a:[
              a_onclick {{
                Eliom_client.get_subpage ~sp ~service:\(eliomclient1)
                  () () >|= fun blocks ->
                List.iter
                  (Dom.appendChild Dom_html.document##body)
                  (XHTML5.M.toeltl blocks)
              }}
            ]
            [pcdata "Click here to get a subpage from server."];


>>
====Refering to parts of the page in client side code
<<code language="ocaml" |

          (let container = ul [ item () ; item () ; item ()] in
           div [p ~a:[
                               a_onclick {{
                                 Dom.appendChild
                                   \(container) (* node is the wrapper keyword for XHTML5.M nodes. *)
                                   (XHTML5.M.toelt (item ()))
                               }}
                  ]
                  [pcdata "Click here to add an item below with the current version of OCaml."];
                container]);

>>
====Refering to server side data in client side code
  In the case you want to send some server side value with your page,
  just do:
<<code language="ocaml" |

          (let my_value = 1.12345 in
           p ~a:[a_onclick
                {{ Dom_html.window##alert
                     (Js.string (string_of_float \(my_value))) ;
                   Lwt.return ()
                }}
                ]
             [pcdata "Click here to see a server side value sent with the page."]);



>>
====Other tests
  <<code language="ocaml" |

          p
            ~a:[
              a_onclick {{
                let coucou = \(Tutoeliom.coucou) in
                let eliomclient1 = \(eliomclient1) in
                (Dom.appendChild
                   (Dom_html.document##body)
                   (XHTML5.M.toelt
                      (p [Eliom_predefmod.Xhtml5.a
                            ~sp ~service:coucou
                            [pcdata "An external link generated client side"]
                            ();
                          pcdata " and ";
                          Eliom_predefmod.Xhtml5.a
                            
                            ~sp ~service:eliomclient1
                            [pcdata "another, inside the application."]
                            ()
                         ]
                      ))
                );
                Lwt.return ()
              }}
            ]
            [pcdata "Click here to add client side generated links."];



        ])


>>
====Using OCaml values as service parameters
It is now possible to send OCaml values to services.
To do that, use the {{{Eliom_parameters.caml}}} function:
<<code language="ocaml" |
let eliomclient3' =
  Eliom_appl.register_post_coservice'
    ~post_params:(caml "isb")
    (fun sp () (i, s, l) ->
      Lwt.return
        [p (pcdata (Printf.sprintf "i = %d, s = %s" i s)::
              List.map (fun a -> pcdata a) l
           )])


let eliomclient3 =
  Eliom_appl.register_service
    ~path:["eliomclient3"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[a_onclick
                {{ Eliom_client.change_page
                     ~sp ~service:\(eliomclient3')
                     () (299, "oo", ["a";"b";"c"])
                }}
              ]
           [pcdata "Click to send Ocaml data"]
        ])

>>
====Sending OCaml values using services
It is possible to do services that send any caml value. For example:
<<code language="ocaml" |
let eliomclient4' =
  Eliom_predefmod.Caml.register_post_coservice'
    ~post_params:unit
    (fun sp () () -> Lwt.return [1; 2; 3])


let eliomclient4 =
  Eliom_appl.register_service
    ~path:["eliomclient4"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[a_onclick
                 {{let body = Dom_html.document##body in
                   Eliom_client.call_caml_service
                     ~sp ~service:\(eliomclient4')
                     () () >|=
                   List.iter
                     (fun i -> Dom.appendChild body
                                 (Dom_html.document##createTextNode
                                    (Js.string (string_of_int i))))
                 }}
              ]
           [pcdata "Click to receive Ocaml data"]
        ])

>>
====Other tests:
<<code language="ocaml" |
let withoutclient =
  Eliom_services.service
    ~path:["withoutclient"]
    ~get_params:unit
    ()


let gotowithoutclient =
  Eliom_services.service
    ~path:["gotowithoutclient"]
    ~get_params:unit
    ()



let _ =
  Eliom_appl.register
    ~options:{Eliom_predefmod.default_appl_service_options
              with Eliom_predefmod.do_not_launch = true}
    ~service:withoutclient
    (fun sp () () ->
       Lwt.return
         [p [pcdata "If the application was not launched before coming here (or if you reload), this page will not launch it. But if it was launched before, it is still running."];
          p
            ~a:[
              a_onclick {{
                Eliom_client.change_page
                  ~sp ~service:\(gotowithoutclient)
                  () ()
              }}
            ]
            [pcdata "Click here to go to a page that launches the application every time (this link does not work if the appl is not launched)."];
          p [a  ~sp ~service:gotowithoutclient
               [pcdata "Same link with ";
                code [pcdata "a"]; pcdata "."] ()];
         ]);
  Eliom_appl.register
    ~service:gotowithoutclient
    (fun sp () () ->
       Lwt.return
         [p [pcdata "The application is launched."];
          p
            ~a:[
              a_onclick {{
                Eliom_client.change_page
                  ~sp ~service:\(withoutclient)
                  () ()
              }}
            ]
            [pcdata "Click here to see the page that does not launch the application."];
          p [a  ~sp ~service:withoutclient
               [pcdata "Same link with ";
                code [pcdata "a"]; pcdata "."] ()];
         ])





let on_load =
  Eliom_appl.register_service
    ~path:["onload"]
    ~get_params:unit
    (fun sp () () ->
      let div =
        div [p [a ~service:eliomclient1 ~sp [pcdata "go to another page"] ()] ]
      in
      Eliom_services.onload ~sp
        {{ Lwt_js.sleep 1. >|= fun () ->
           Dom.appendChild \(div)
             (XHTML5.M.toelt (p [pcdata "on_load executed after 1s."]))
         }};
      Eliom_services.onload ~sp
        {{ Lwt_js.sleep 3. >|= fun () ->
           Dom.appendChild \(div)
             (XHTML5.M.toelt (p [pcdata "on_load executed after 3s."]))
         }};
      Eliom_services.onunload ~sp
        {{
          Dom.appendChild \(div)
          (XHTML5.M.toelt (p [pcdata "on_unload executed. Waiting 1s."]));
          Lwt_js.sleep 1.
        }};
      Lwt.return [div]
    )



>>
====Implicit registration of services to implement distant function calls
<<code language="ocaml" |
>>
<<code language="ocaml" |
>>
<<code language="ocaml" |
>>
        >> <<|onecol~>>
      >> <<|colprincipale~>>
<<code language="ocaml" |
>>
