=Services=

<<div class="wip"|Lots of links and ref currently broken>>

In this chapter and all the following, we suppose you've read the
Ocsigen framework tutorial (part * *tuto) which gives an overview of
the whole project and explains the main concepts. In particular, we suppose
you have basic knowledge on how to define services with parameters,
create links and forms, and use Eliom references.

Each chapter in this part goes into the full details of one Eliom notion.
They can be read in any order, according to your needs.

==General principles==

===Defining services===

With Eliom, pages are generated by //services//.
A service is typically associated to an URL, possibly with parameters,
and you need to register on this service the OCaml function
(//service handler//) that will generate the page.

For example, the following piece of code defines a service without
parameter, attached to the path {{{/coucou}}} of the web site,
and registers on it a function which generates a simple HTML page:

<<code language="ocaml"|let coucou =
  Eliom_output.Xhtml5.register_service
    ~path:["coucou"]
    ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (XHTML5.M.html
          (XHTML5.M.head (XHTML5.M.title (XHTML5.M.pcdata "")) [])
          (XHTML5.M.body [XHTML5.M.h1 [XHTML5.M.pcdata "Hallo!"]])))
>>

The handler parameters are GET and POST parameters (see chapter * *)

The creation of the service and registration of the handler can be splitted
in two distinct operation using {{{Eliom_output.Xhtml5.service}}}
and {{{Eliom_services.register}}} (see for example in section * * calc).

Services registered with <<span class="code"|register_service>>
are the main entry points to the Web site.
They are available for all users. We call them //main services//.

Here is an example of service with side effects:
<<code language="ocaml"|open XHTML5.M
let count =
  let next =
    let c = ref 0 in
      (fun () -> c := !c + 1; !c)
  in
  Eliom_output.Xhtml5.register_service
    ~path:["count"]
    ~get_params:unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "counter")) [])
         (body [p [pcdata (string_of_int (next ()))]])))
>>
It implements a counter of the number of requests to this service.
(See <<||latex section >>[[manual/dev/state#perscount|here]] for a version of this
counter that persists after relaunching the server).


<<div class="encadre"|
====Paths====


<<span class="code"|["foo"; "bar"]>> corresponds to the URL
<<span class="code"|foo/bar>>.  \\
<<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
(that is: the default page of the directory <<span class="code"|dir>>).   \\
The empty list <<span class="code"|[]>> is equivalent to <<span class="code"|[""]>>.\\

//Warning://
You cannot create a service on path <<span class="code"|["foo"]>>
(URL <<span class="code"|foo>>, without slash at the end)
and another on path <<span class="code"|["foo";"bar"]>>
(URL <<span class="code"|foo/bar>>) because <<span class="code"|foo>> can not be
both a directory and a file.
Be also careful not to use a path as a directory with
Eliom, if it is a file for Staticmod (and vice versa).

//Warning://
<<span class="code"|["foo";"bar"]>> is not equivalent to
<<span class="code"|["foo/bar"]>>.
In the latter, the "/" will be encoded in the URL.\\

The following example shows how to define the default page for
a directory.
<<code language="ocaml"|open XHTML5.M
let default = Eliom_output.Xhtml5.register_service ["rep";""] unit
  (fun () () ->
    Lwt.return
     (html
      (head (title (pcdata "")) [])
      (body [p [pcdata "default page. rep is redirected to rep/"]])))
>>

>><<|encadre>>

See in the tutorial and in chapter * * how to compile and run an Eliom site.


===Services and Lwt===

Remember that a Web site written with Eliom is an OCaml application.
This application must be able to handle several requests at the same
time, in order to prevent a single request from making the whole server hang.
To make this possible, Ocsigen is using //cooperative threads//
(implemented in monadic style) which make them really easy
to use (see <<ocsigendoc version="dev" file="Lwt.html"|<<span class="code"|Lwt>>>> module).

As it doesn't cooperate, the following page will stop the
server for 5 seconds. No one will be able to query the server during
this period:

<<code class="donotrun" language="ocaml" |open XHTML5.M
let looong =
  Eliom_output.Xhtml5.register_service
    ~path:["looong"]
    ~get_params:unit
    (fun () () ->
       Unix.sleep 5;
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>


To solve this problem, use a cooperative version of
<<ocsigendoc version="dev" file="Lwt_unix.html" fragment="VALsleep"|<<span class="code"|sleep>>>>:

<<code language="ocaml"|open XHTML5.M
let looong =
  Eliom_output.Xhtml5.register_service
    ~path:["looong"]
    ~get_params:unit
    (fun () () ->
       Lwt_unix.sleep 5.0 ~>>= fun () ->
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>

If you want to use, say, a database library that is not written
 in cooperative way, but is thread safe for preemptive threads,
 use the <<span class="code"|Lwt_preemptive>> module to
 detach the computation. In the following example,
 we simulate the request by a call to <<span class="code"|Unix.sleep>>:

<<code language="ocaml"|let looong2 =
  register_service
    ~path:["looong2"]
    ~get_params:unit
    (fun () () ->
       Lwt_preemptive.detach Unix.sleep 5 ~>>= fun () ->
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>



===GET and POST methods===

The HTTP protocol allows two methods to do requests:
* The GET method is intended to be used to retrieve a document
from the server. The page is generated mainly according to the information
contained in the URL. URLs may contain parameters, and these parameters
may come from HTML forms.
* The POST method is used to send data to the server, for example files,
but also values coming from an HTML form. Data is sent in the body of the HTTP
request. It is possible to use the POST method with an empty body.

In HTML, it is not possible to mix GET and POST parameters in forms, but
a form parameter can use an URL with (fixed) GET parameters.
It is not possible either to define links using the POST method.

<<div class="encadre"|
POST and GET methods are not equivalent, and you must be very careful
if you want to use one or the other.\\

Remember that only GET services are bookmarkable. The HTTP method and
POST parameters are not stored in bookmarks.\\
Use the GET method if you want the user to be able to come back to the service
later or to write the URL manually.\\
Use the POST method for //hidden service//, that is when you want a
different behaviour
between the first click and a reload of the page. Usually using
POST method triggers an action on server side
(like a payment, or adding something in a database), and you don't want
it to succeed several times if the page is reloaded or bookmarked.
>>

The URL of a POST service must correspond to an existing GET service,
otherwise, no one will answer if you turn back later with the GET method.
To ensure that the corresponding GET service exists, POST services
are created using a function taking a GET service (called //fallback//)
as parameter, instead of the path. Example:
<<code language="ocaml"|open XHTML5.M
let get_service =
  Eliom_output.Xhtml5.register_service
    ~path:["post"]
    ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "")) [])
         (body [h1 [pcdata "Version of the page with GET method"]])))

let post_service =
  Eliom_output.Xhtml5.register_post_service
    ~fallback:get_service
    ~post_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "")) [])
         (body [h1 [pcdata "Version of the page using POST method"]])))
>>



===External services===

It is possible to define external services, that is, services that belong
to an external Web site (on the same server of not).
To do that, use the functions {{{Eliom_services.external_service}}}
(for using the GET method),
or {{{Eliom_services.external_post_service}}}
(for using the POST method).

See an example section * * links.

===@@id="p3staticparts"@@Using Eliom together with Staticmod===

<<div class="wip"|ou alors faire une section static content, en disant bien
qu'il ne faut pas le mettre dans le ml (et suggérer db, et fichiers).
De tte façon il faut le dire qqpart.
>>


The <<span class="code"|staticmod>> extension allows to associate
to your site a static directory
where you can put all the static (non generated) parts of your
web-site (for examples images and stylesheets).
See  <<span class="wip"|QUOI>> to learn how to do that.
Staticmod can be used together with Eliom.

A predefined service can be used to make links to static files.
Get it using
<<span class="code"|(static_dir ())>>.
That service takes as string parameter the name of the file.
\\

For example
<<code language="ocaml"|a (static_dir ()) [pcdata "download image"] "ocsigen10.png"
>>
creates this link: [[site:ocsigen10.png|download image]]

It is also possible to send static pages using Eliom, using
<<span class="code"|Eliom_output.Files>>
([[manual/dev/services#p3eliomfiles|see later]]).




==Predefined output modules for services==

All the services we have defined so far in this section are registered using
{{{Eliom_output.Xhtml5.register_service}}} and the handler functions
return a value of type {{{Xhtmltypes5.xhtml XHTML5.M.elt Lwt.t}}}.
If you want to do other types of outputs, you need to use other registration
modules, taken from a large set of predefined modules (output raw text,
redirections, files, portions of pages, etc.). It is also possible to create
your own output modules.

Output modules may define options for the registration function.
For example, the redirection ouput module allows to choose between permanent
and temporary registration, and the module {{{Eliom_output.Xhtml5}}} 
allows to personnalize the document type to be included in the page.
For example:

<<code language="ocaml"|Eliom_output.Xhtml5.register_service
  ~options:(`Doctype "my doctype")
  ~path:["coucou"]
  ~get_params:Eliom_parameters.unit
>>



===Generating HTML pages===

Ocsigen provides several ways to generate and type xhtml pages.

* The default technique to produce HTML5 pages using Eliom is the XHTML5.M
   module. It is the only one supported for client side Eliom programs for now.
   This module provides a typing based on OCaml's polymorphic variants,
   that ensures at compile time that the pages you will generate will
   respect the recommendations of the W3C (or be very close).
   There also exist another module called XHTML.M that implements XHTML 1.1.
* It is also possible to use a syntax extension to write your pages with the
   usual XHTML syntax. This solution is also typed with polymorphic variants
   and is compatible with the previous one.
* The most powerful typing of pages is done with OcamlDuce. 
  To take benefit of it, use OCamlDuce instead of OCaml.
* You can also choose to generate untyped xhtml as text.

===XHTML5.M and XHTML.M===

The types in OCaml closest to XML types are //polymorphic variants//.
Ocsigen is using them to provide a module with very good XHTML typing.
The full documentation is available <<ocsigendoc file='XHTML.M.html'|in
the interface of the module>>.
<<div class="wip"|put it here (?!)>>

===XHTML syntax extension===

<<div class="wip"|Compatibility with HTML5?>>

Ocsigen also has a syntax extension for OCaml that enables to writes pages
using HTML syntax (but you are free not to use it).
This is convenient for example if
you want to include (parts of) HTML pages that have been
created by third party.
This syntax extension uses the same polymorphic variants as
XHTML5.M, thus this solution can be mixed with the previous one.

For example, the following code:
{{{
<< <html>
     <head><title></title></head>
     <body><h1>plop</h1></body>
   </html> >>
}}}
is a caml value of type {{{Xhtmltypes5.xhtml XHTML5.M.elt}}}.

To compile a module containing this syntax, you need the camlp4 preprocessor:
{{{
ocamlc -I /path_to/ocsigen/
 -pp "camlp4o /path_to/ocsigen/xhtmlsyntax.cma -loc loc"
 -c your_module.ml
}}}
You can insert OCaml expressions of type {{{'a XHTML.M.elt}}} inside html using {{{$...$}}}, like this:
{{{
let oc = << <em>Ocsigen</em> >> in 
<< <p>$oc$ will revolutionize web programming.</p> >>
}}}
<<div class="wip"| remove \ before $, _ in code, everywhere in pdf version!!!!!!!!!! >>

You can insert OCaml expressions of type string inside html using 
{{{$str:... $}}}, like this:
{{{
let i = 4 in 
<< <p>i is equal to $str:string_of_int i$</p> >>
}}}
If you want to use a dollar in your page, just write it twice.

You can write a list of xhtml expressions using the syntax {{{<:xmllist<...>>}}}, for example:
{{{
<:xmllist< <p>hello</p> <div></div> >>
}}}
Here are some other examples showing what you can do:
{{{
<< <ul class=$ulclass$ $list:other_attrs$>
     $first_il$ 
     $list:items$
   </ul> >>
}}}
Warning: lists antiquotations are allowed only at the end (before a closing tag). For example, the following is not valid:
{{{
<< <ul $list:other_attrs$ class=$ulclass$>
     $list:items$ 
     $last_il$
   </ul> >>
}}}
The syntax extension is not allowed in patterns for now.

//Warning:// The two syntaxes are not equivalent for typing.
 Using the syntax extension will do less checking.
 For example the following code is accepted but not valid
 regarding HTML5 standard (because <<span class="code"|<head>>>
 must contain a title):
  
<<code language="ocaml"|<< <html>
     <head></head>
     <body><h1>plop</h1></body>
   </html> ~>>
>>

We recommend you to use
the functions from <<ocsigendoc version="dev" file="XHTML5.M.html"|<<span class="code"|XHTML5.M>>>>, as you will (almost)
always get valid xhtml.
Use the syntax extension for example to enclose already created pieces
of HTML, and check your pages validity with the
[[http://validator.w3.org/| W3C validator]].
  



===OCamlduce===

OCaml's type system is not powerful enough to type XML. OCamlduce
manual says: //"The goal of the OCamlDuce project is to extend the
OCaml language with features to make it easier to write safe and
efficient complex applications that need to deal with XML documents.
In particular, it relies on a notion of types and patterns to
guarantee statically that all the possible input documents are
correctly processed, and that only valid output documents are
produced."//

Ocamlduce's full documentation is available from
[[http://www.cduce.org/ocaml.html|here]].

If OCamlDuce is installed on your system, it is now possible to use
it instead of XHTML.M and Eliom_output.Xhtml
to typecheck your pages. You will get a stronger type checking
and more flexibility (easier to use other XML types, to parse
incoming XML data, etc.).

But Ocamlduce is not compatible with Camlp4 syntax extensions
and client server Eliom applications support only XHTML5.M (for now).


To use it, make sure that you have Eliom compiled with OCamlDuce
 support. Then dynlink <<span class="code"|ocamlduce.cma>> and
  <<span class="code"|eliomduce.cma>> from the configuration file
(after <<span class="code"|eliom.cma>>).
Then use <<ocsigendoc version="dev" file="Eliom_duce.Xhtml.html"|<<span class="code"|Eliom_duce.Xhtml>>>> instead of
<<ocsigendoc version="dev" file="Eliom_output.Xhtml.html"|<<span class="code"|Eliom_output.Xhtml>>>> to register your pages.

Here is an example:
<<code language="ocaml"|
let s =
  Eliom_duce.Xhtml.register_service
    ~path:[""]
    ~get_params:unit
    (fun () () ->
      Lwt.return
        {{ <html>
             [<head> [<title> ""]
              <body> [<h1> "Page type checked by OCamlDuce"]] }}) 
>>  



===Text XHTML===

The last possibility is to use untyped xhtml. Just build strings
containing your pages. Here is an example:

<<code language="ocaml"|let coucoutext =
  Eliom_output.HtmlText.register_service
    ~path:["coucoutext"]
    ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        ("<html>n'importe quoi "^
         (Eliom_output.HtmlText.a coucou "clic" ())^
         "</html>"))
>>





===Summary of predefined output modules===

<<div class="wip"|Add types and options for each module?>>


Services can send several types of data, using several predefined modules.
It is also possible to create your own output modules (see later).
The main predefined output modules are:

<<| |@@class="empty"@@|=@@class="col2 c"@@Services|=@@colspan="2" class="col2 c"@@Coservices|
|@@class="empty"@@|=@@class="col2 c"@@|=@@class="col2 c"@@attached\\named~ /~ anonymous|=@@class="col2 c"@@non-attached\\named~ /~ anonymous|

|=Module|=description|=type|=options|
>>

;<<ocsigendoc version="dev" file="Eliom_output.Xhtml5.html"|<<span class="code"|Eliom_output.Xhtml5>>>> (and <<ocsigendoc version="dev" file="Eliom_output.Xhtml.html"|<<span class="code"|Eliom_output.Xhtml>>>>)
: Allows to register functions that generate xhtml pages statically checked using polymorphic variant types. You may use constructor functions from <<ocsigendoc version="dev" file="XHTML.M.html"|<<span class="code"|XHTML.M>>>> or a syntax extension close to the standard xhtml syntax.
;<<ocsigendoc version="dev" file="Eliom_output.Xhtml5compact.html"|<<span class="code"|Eliom_output.Xhtml5compact>>>> (and <<ocsigendoc version="dev" file="Eliom_output.Xhtmlcompact.html"|<<span class="code"|Eliom_output.Xhtmlcompact>>>>)
: Same, but without pretty printing (does not add spaces or line breaks).
;<<ocsigendoc version="dev" file="Eliom_output.Blocks5.html"|<<span class="code"|Eliom_output.Blocks5>>>> (and <<ocsigendoc version="dev" file="Eliom_output.Blocks.html"|<<span class="code"|Eliom_output.Blocks>>>>)
: Allows to register functions that generate a portion of page using <<ocsigendoc version="dev" file="XHTML5.M.html"|<<span class="code"|XHTML5.M>>>> (resp <<ocsigendoc version="dev" file="XHTML.M.html"|<<span class="code"|XHTML.M>>>>) or the syntax extension. (useful for <<span class="code"|XMLHttpRequest>> requests for example).
;<<ocsigendoc version="dev" file="Eliom_duce.Xhtml.html"|<<span class="code"|Eliom_duce.Xhtml>>>>
: Allows to register functions that generate XHTML 1.1 pages   statically checked using <<span class="code"|OCamlduce>>. Typing is   stricter, and you need a modified version of the OCaml compiler   (OCamlduce).
;<<ocsigendoc version="dev" file="Eliom_output.HtmlText.html"|<<span class="code"|Eliom_output.HtmlText>>>>
: Allows to register functions that   generate text html pages, without any typechecking of the content.   The content type sent by the server is "text/html".
;<<ocsigendoc version="dev" file="Eliom_output.CssText.html"|<<span class="code"|Eliom_output.CssText>>>>
: Allows to register functions that   generate CSS pages, without any typechecking of the content.   The content type sent by the server is "{{{text/css}}}".
;<<ocsigendoc version="dev" file="Eliom_output.Text.html"|<<span class="code"|Eliom_output.Text>>>>
: Allows to register functions that   generate text pages, without any typechecking of the content.   The services return a pair of strings. The first one is the content   of the page, the second one is the content type.
;<<ocsigendoc version="dev" file="Eliom_output.Action.html"|<<span class="code"|Eliom_output.Action>>>>
: Allows to register actions (functions that do not generate any page, see * *). The page corresponding to the URL (without the coservice parameter that triggered the action) is reloaded after the action by default if possible.
;<<ocsigendoc version="dev" file="Eliom_output.Unit.html"|<<span class="code"|Eliom_output.Unit>>>>
: is like <<ocsigendoc version="dev" file="Eliom_output.Action.html"|<<span class="code"|Eliom_output.Action>>>> but the URL is not reloaded after the action. (Same as {{{Eliom_output.Action}}} with {{{[`NoReload]}}} option).
;<<ocsigendoc version="dev" file="Eliom_output.Redirection.html"|<<span class="code"|Eliom_output.Redirection>>>>
: Allows to register HTTP redirections. The handler returns the service (without parameter) of the page you want to redirect to. The browser will get a 301 or 307 code in answer and redo the request to the new URL. To specify whether you want temporary (307) or permanent (301) redirections, use the <<span class="code"|?options>> parameter of registration functions. For example: <<span class="code"|register ~options:`Permanent ...>> or <<span class="code"|register ~options:`Temporary ...>>.
;<<ocsigendoc version="dev" file="Eliom_output.Redirection.html"|<<span class="code"|Eliom_output.String_redirection>>>>
: Same but the ouput type is a string. Use with care! Warning: According to the RFC of the HTTP protocol, the URL must be absolute!
;<<ocsigendoc version="dev" file="Eliom_output.Files.html"|<<span class="code"|Eliom_output.Files>>>>
: Allows to register services that send files.
;<<ocsigendoc version="dev" file="Eliom_output.Any.html"|<<span class="code"|Eliom_output.Any>>>>
: Allows to register services that can choose what they send, for example an xhtml page or a file, depending on some situation (parameter, user logged or not, page present in a cache ...). It is also possible to create your own modules for other types of pages. See later * * for an example of use.
;<<ocsigendoc version="dev" file="Eliom_output.Eliom_appl.html"|<<span class="code"|Eliom_output.Eliom_appl>>>>
: is a functor that generates a module allowing to create services belonging to a client-server Elioml application (see chapter * *)
;<<ocsigendoc version="dev" file="Eliom_output.Caml.html"|<<span class="code"|Eliom_output.Caml>>>>
: allows to register services sending marshalled OCaml values

<<div class="wip"|Missing modules?>>


===@@id="p3eliomfiles"@@Sending files
  
  
You may want to register a service that will send files.
  To do that, use the <<ocsigendoc version="dev" file="Eliom_output.Files.html"|<<span class="code"|Eliom_output.Files>>>> module. Example:
  
  

  
<<code language="ocaml"|
let sendfile =
  Files.register_service
    ~path:["sendfile"]
    ~get_params:unit
    (fun () () -> return "filename")

>>

Other example, with "suffix" services (see * *):
<<code language="ocaml"|
let sendfile2 =
  Files.register_service
    ~path:["files"]
    ~get_params:(suffix (all_suffix "filename"))
    (fun s () -> return ("//path//"^(Ocsigen_lib.string_of_url_path ~encode:false s)))
>>

The extension <<span class="code"|Staticmod>> is another way to
handle static files.
  
  

===Sending portions of pages
  
  
 The <<ocsigendoc version="dev" file="Eliom_output.Blocks5.html"|<<span class="code"|Eliom_output.Blocks5>>>> and <<ocsigendoc version="dev" file="Eliom_output.Blocks.html"|<<span class="code"|Eliom_output.Blocks>>>> modules allow to register services that send portions of pages, of any "block" type for XHTML5.M (resp. XHTML.M).
 It is sometimes useful to create AJAX pages
 (i.e. pages using the <<span class="code"|XMLHttpRequest>> Javascript object).
 Note that the service returns a list of blocks.
  

<<code language="ocaml"|let divpage =
  Eliom_output.Blocks.register_service
    ~path:["div"]
    ~get_params:unit
    (fun () () ->
      Lwt.return
        [div [h2 [pcdata "Hallo"];
              p [pcdata "Blablablabla"] ]])
>>

  
 The <<ocsigendoc version="dev" file="Eliom_output.SubXhtml.html"|<<span class="code"|Eliom_output.SubXhtml>>>> module allows to create other modules for
 registering portions of pages of other types.
 For example, <<ocsigendoc version="dev" file="Eliom_output.Blocks5.html"|<<span class="code"|Eliom_output.Blocks5>>>>
 is defined by:
  

  
<<code language="ocaml"|module Blocks5 = SubXhtml(struct
  type content = Xhtml5types.body_content
  include Xhtml_format.Xhtml5Info
  include Xhtml5pretty_streams
end)
>>


===Redirections
  
  
 The <<ocsigendoc version="dev" file="Eliom_output.Redirection.html"|<<span class="code"|Eliom_output.Redirection>>>> module allows to register HTTP redirections.\\
If a request is done towards such a service, the server asks the browser
to retry with another URL.

Such services return a GET service without parameter at all.
Example:
<<code language="ocaml"|let redir1 = Eliom_output.Redirection.register_service
    ~options:`Temporary
    ~path:["redir"]
    ~get_params:Eliom_parameters.unit
   (fun () () -> Lwt.return coucou)
>>

  
 If you want to give parameters to such services, use
 <<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpreapply"|<<span class="code"|Eliom_services.preapply>>>> (see also 
 [[manual/dev/services#p3preapplied|later in the tutorial]]).
 Example:

  
 <<code language="ocaml"|let redir = Eliom_output.Redirection.register_service
    ~options:`Temporary
    ~path:["redir"]
    ~get_params:(int "o")
   (fun o () ->
      Lwt.return
        (Eliom_services.preapply coucou_params (o,(22,"ee"))))
>>

  
The <<span class="code"|options>> parameter may be either
  <<span class="code"|`Temporary>> or <<span class="code"|`Permanent>>.
  

  
[[site:tuto/redir?o=11| Try it]].

Note that the cost of a redirection is one more query and
one more answer.


===@@id="p2actions"@@Actions

 
Actions are services that do not generate any page.
Use them to perform an effect on the server (connection/disconnection
of a user, adding something in a shopping basket, delete a message in
a forum, etc.). By default,
the page you link to is redisplayed after the action.
For ex, when you have the same form (or link) on several pages
(for ex a connection form),
instead of making a version with post params of all these pages,
you can use only one action, registered on a //non-attached coservice//
(see below).
<<|To register actions, just use the module <<ocsigendoc version="dev" file="Eliom_output.Action.html"|<<span class="code"|Eliom_output.Action>>>>
instead of <<ocsigendoc version="dev" file="Eliom_output.Xhtml.html"|<<span class="code"|Eliom_output.Xhtml>>>> (or <<ocsigendoc version="dev" file="Eliom_duce.Xhtml.html"|<<span class="code"|Eliom_duce.Xhtml>>>>, etc.).
For example
 <<span class="Cem"|<<ocsigendoc version="dev" file="Eliom_output.Action.html" fragment="VALregister"|<<span class="code"|Eliom_output.Action.register>>>>>>,
 <<span class="Cem"|<<ocsigendoc version="dev" file="Eliom_output.Action.html" fragment="VALregister_service"|<<span class="code"|Eliom_output.Action.register_service>>>>>>.
>>
\\

See more details and an example in the section about non-attached coservices
below, or in section * * connection-of-user.

The return type of action handlers is
<<span class="code"|unit Lwt.t>>.
We will see [[manual/dev/services#p3infofallbacks|later]] how to transmit information
to the service that will take in charge the generation of the page.\\
 
A very common use of actions, together with non-attached coservices,
is the implementation of login forms, or disconnection links.
An example is given in the chapter about the server side state 
of the application (section sec-state-connect).
In that case, actions and non-attached coservices make staightforward
the implementation of the behaviour you generally want for such features:
* Connection and disconnection stay on the same page,
* If you want a connection/disconnection form on each page, no need
  to create a version with POST parameters of each service.

The implementation of the same behaviour with usual Web programming techniques
is usually much more complicated.



===Registering services that decide what they want to send===
  
You may want to register a service that will send, for instance,
  sometimes
  an XHTML page, sometimes a file, sometimes something else.
  To do that, use the <<ocsigendoc version="dev" file="Eliom_output.Any.html"|<<span class="code"|Eliom_output.Any>>>> module, together
  with the <<span class="code"|send>> function of the module you want
  to use. Example:
  
  
<<code language="ocaml"|let send_any =
  Eliom_output.Any.register_service
    ~path:["sendany"]
    ~get_params:(string "type")
   (fun s () ->
     if s = "valid"
     then
       Eliom_output.Xhtml.send
         (html
            (head (title (pcdata "")) [])
            (body [p [pcdata
                        "This page has been statically typechecked.
                         If you change the parameter in the URL you will
                         get an unchecked text page"]]))
     else
       Eliom_output.HtmlText.send
         "<html><body><p>It is not a valid page. Put type=\"valid\" in the
          URL to get a typechecked page.</p></body></html>"
   )
>>

  
  See [[site:tuto/sendany?type=valid| a valid page]],
  and [[site:tuto/sendany?type=non+valid| a non valid page]].
  
  

  
You may also use <<ocsigendoc version="dev" file="Eliom_output.Any.html"|<<span class="code"|Eliom_output.Any>>>> to personnalize the charset
(default charset is set in configuration file), the HTTP code,
the content type or to add some HTTP headers.
To do that use the optional parameters
(<<span class="code"|?code>>, <<span class="code"|?charset>> etc.) of the
 <<span class="code"|send>> function.

===Creating your own output modules===

<<div class="wip"|To be written>>

==Service identification mechanism==

The choice of the service to handle a request is done automatically by
Eliom, according the HTTP method (GET or POST), the URL path
and/or (GET or POST) parameters. This is called
//service identification//.
Up to now, we have seen very simple services. But
Eliom's service identification mechanism is very powerful and
you can rely on it to simplify a lot the implementation of complex
Web interaction!

Before beginning the implementation of a Web site,
think about the URLs you want to create as entry points to your Web site,
and the services you want to provide. It is not clean to pollute
the path tree by creating "dummy URLs"
that will be used only to perform an effect and do a redirection.
Eliom always has a better solution.\\


Services we used, so far, are called //main services//.
But there are other kinds of services depending on the precise
behaviour you want for links and forms. Clicking on a link or a form
may trigger:



*the request of a new document (page) (or not),
*the sending of data to the server using the POST method (or not),
*an action on the server (or not),
*a change of URL (or not).




To take into account all possible behaviours with respect to URLs, 
  Eliom uses three kinds of services. We give a quick definition here,
and we will give more details and example in the following of this section:
;@@class="blue"@ @@Main services
:are the main entry points of your sites.
  Created by <<span class="code"|service>> or
  <<span class="code"|post_service>>.
  They correspond to the public URLs of your Web site, and will last
  forever.
;Attached coservices
:are services that share their
  location (URL) with a main service (fallback).
  They are distinguished from that main service using a special parameter
  (added automatically by Eliom), containing either the name of the
  coservice or a number generated automatically.
  They are often created dynamically for one user
  (usually in the session table), depending on previous interaction
  during the session.
  Sometimes, you want them to disappear after a timeout, letting
  the fallback answer afterwards.
  Another use of (POST) coservices is to customize one
  button but not the page it leads to (like the disconnect button
  in the example of sessions with //actions// as below: it goes to the
  page corresponding to the visible URL, but also disconnect the user
  as side effect).
;Non-attached coservices
:are
  coservices that are not
  attached to a particular URL. A link to a non-attached
  coservice will go to the current URL with a special parameter
  containing either the name of the service, or a number generated 
  automatically (and different each time).
  It is useful when you want the same link or form on several pages
  (for example a connection box) but you don't want to go to another
  URL. Non-attached coservices are often used with //actions//
  (see below).

To summarize, if you want to go to another URL, use
attached coservices. If you want to stay on the same URL
use non-attached coservices.

As mentionned above, attached and non-attached coservices can be //named//
or //anonymous// (in the latter case, a random and cryptographically safe
number is generated by Eliom). Use named coservices when you want to
recreate them after relaunching the server without breaking the links
forms and bookmarks towards them. Use anonymous coservices for example
when you need to create automatically a new coservice for a short amount
of time. Coservices are anonymous by default. Add the optional {{{~name}}}
parameter if you want them to be named.

<<div class="encadre"|
====Dynamic creation of services====

One key feature of Eliom, that exists in very few Web programming frameworks,
is the ability to //create dynamically new services//.

This allows for example to create personalized services that depend on previous
interaction with one user! This corresponds exactly to what is called
//continuation based Web programming//. As we will see later
(example * calc * *), this make really easy to implement a succession
of links and forms depending one from another, and with the expected
behaviour if the user press the back button or duplicate the browser
window.
Such a behaviour is difficult to simulate with traditional Web
programming and is a cause of mistake in many well known Web site
(for example travel ticket booking, etc).

Continuations for Web programming have been introduced by
<<span class="wip"|Missing tilde in link before queinnec>>
[[http://www-spi.lip6.fr/queinnec/PDF/www.pdf| Christian Queinnec]],
and are a big step in the understanding of Web interaction.

Some programming languages (Scheme...) allow to manipulate
continuations using //control operators// (like
<<span class="code"|call/cc>>). The style of programming used by Eliom
is closer to //Continuation Passing Style// (CPS), and has the
advantage that it does not need control operators, and fits
very well Web programming.

If you want dynamic services dedicated to a particular user,
it is possible (even if not necessary)
to register it with scope {{{`Session}}} (see chapter * *).\\

Another use of dynamic services is to add new features to your Web site
(for example a user creates its blog, and you want to add a new URL for her).
In that case, be very careful to recreate the services when relaunching the
server (for example by taking the information from a databse).
>><<|encadre>>

===@@id="p2coservices"@@Coservices

Very often, GET anonymous coservices are created dynamically with
respect to previous interaction with the user (and are registered
with scope {{{`Session}}}). They allow to give a precise semantics to the
"back" button of the browser (be sure that you will go back in the
past) or bookmarks, or duplication of the browser's window.
(See the [[manual/dev/services#p3coservicesinsessiontable|<<span class="code"|calc>>]] example below).

Use POST coservices if you want to particularize a link or form,
but not the URL it points to. More precisely, POST coservices are mainly
used in two situations:
* For the same purpose as GET coservices (new services
corresponding to precise points of the interaction with the user)
but when you don't want this service to be bookmarkable.
* To create a button that leads to a service after having performed
a side-effect. For example a disconnection button that leads to the main
page of the site, but with the side effect of disconnecting the user.

To create a coservice, use
<<span class="Cem"|<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALcoservice"|<<span class="code"|Eliom_services.coservice>>>>>> and
<<span class="Cem"|<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpost_coservice"|<<span class="code"|Eliom_services.post_coservice>>>>>>.
Like <<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpost_service"|<<span class="code"|Eliom_services.post_service>>>>,
they take a public service as parameter
(labeled <<span class="code"|fallback>>)
to be used as fallback when the user comes back without the coservice
identifier (for example if it was a POST coservice and/or the coservice
has expired).
  

  
The following example shows the difference between GET coservices
(bookmarkable) and POST coservices:
  
<<code language="ocaml"|(************************************************************)
(************** Coservices. Basic examples ******************)
(************************************************************)

(* -------------------------------------------------------- *)
(* We create one main service and two coservices:           *)

let coservices_example =
  Eliom_services.service
    ~path:["coserv"]
    ~get_params:Eliom_parameters.unit
    ()

let coservices_example_post =
  Eliom_services.post_coservice
    ~fallback:coservices_example
    ~post_params:Eliom_parameters.unit
    ()

let coservices_example_get =
  Eliom_services.coservice
    ~fallback:coservices_example
    ~get_params:Eliom_parameters.unit
    ()


(* -------------------------------------------------------- *)
(* The three of them display the same page,                 *)
(* but the coservices change the counter.                   *)

let _ =
  let c = ref 0 in
  let page () () =
    let l3 = Eliom_output.Xhtml.post_form coservices_example_post
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"incr i (post)" ()]]) ()
    in
    let l4 = Eliom_output.Xhtml.get_form coservices_example_get
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"incr i (get)" ()]])
    in
    return
      (html
       (head (title (pcdata "")) [])
       (body [p [pcdata "i is equal to ";
                 pcdata (string_of_int !c); br ();
                 a coservices_example [pcdata "reload"] (); br ();
                 a coservices_example_get [pcdata "incr i"] ()];
              l3;
              l4]))
  in
  Eliom_output.Xhtml.register coservices_example page;
  let f () () = c := !c + 1; page () () in
  Eliom_output.Xhtml.register coservices_example_post f;
  Eliom_output.Xhtml.register coservices_example_get f
>>

  
Try [[site:tuto/coserv|<<span class="code"|coserv>>]].
  

  
Note that if the coservice does not exist (for example it
has expired), the fallback is called.

In this example, coservices do not take any parameters
(but the coservice identifier), but you can create coservices with
parameters. Note that the fallback of a GET coservice cannot take
parameters. But as coservices parameters have special
names, it is possible to use a "pre-applied" service as fallback
([[manual/dev/services#p3preapplied|see later]]).


===@@id="p3coservicesinsessiontable"@@Dynamic coservices===

You can register (anonymous) coservices (usually with scope {{{`Session}}}) 
to create dynamically new services dedicated to an user.
Here is an example of pages that add two integers.
Once the first number is sent by the user, a coservice
is created and registered in the session table. This service
takes the second number as parameter and displays the result of
the sum with the first one.
Try to duplicate the pages and/or to use the back button of your
navigator to verify that it has the expected behaviour.

(See chapter * * if you want more explanations on forms and parameters).
  
<<code language="ocaml"|(************************************************************)
(*************** calc: sum of two integers ******************)
(************************************************************)

(*zap* *)
let state_name = "calc_example"
(* *zap*)
(* -------------------------------------------------------- *)
(* We create two main services on the same URL,             *)
(* one with a GET integer parameter:                        *)

let calc =
  Eliom_output.Xhtml5.service
    ~path:["calc"]
    ~get_params:Eliom_parameters.unit
    ()

let calc_i =
  Eliom_output.Xhtml5.service
    ~path:["calc"]
    ~get_params:(Eliom_parameters.int "i")
    ()


(* -------------------------------------------------------- *)
(* The handler for the service without parameter.           *)
(* It displays a form where you can write an integer value: *)

let calc_handler () () =
  let create_form intname =
    [p [pcdata "Write a number: ";
        Eliom_output.Xhtml.int_input ~input_type:`Text ~name:intname ();
        br ();
        Eliom_output.Xhtml.string_input ~input_type:`Submit ~value:"Send" ()]]
  in
  let f = Eliom_output.Xhtml.get_form calc_i create_form in
  return
    (html
       (head (title (pcdata "")) [])
       (body [f]))


(* -------------------------------------------------------- *)
(* The handler for the service with parameter.              *)
(* It creates dynamically and registers a new coservice     *)
(* with one GET integer parameter.                          *)
(* This new coservice depends on the first value (i)        *)
(* entered by the user.                                     *)

let calc_i_handler i () =
  let create_form is =
    (fun entier ->
       [p [pcdata (is^" + ");
           int_input ~input_type:`Text ~name:entier ();
           br ();
           string_input ~input_type:`Submit ~value:"Sum" ()]])
  in
  let is = string_of_int i in
  let calc_result =
    register_coservice ~scope:`Session
      ~fallback:calc
      ~get_params:(int "j")
      (fun j () ->
        let js = string_of_int j in
        let ijs = string_of_int (i+j) in
        return
          (html
             (head (title (pcdata "")) [])
             (body
                [p [pcdata (is^" + "^js^" = "^ijs)]])))
  in
  let f = get_form calc_result (create_form is) in
  return
    (html
       (head (title (pcdata "")) [])
       (body [f]))


(* -------------------------------------------------------- *)
(* Registration of main services:                           *)

let () =
  Eliom_output.Xhtml.register calc   calc_handler;
  Eliom_output.Xhtml.register calc_i calc_i_handler
>>

  
[[site:tuto/calc| See the result]].




<<div class="encadre"|
====URLs


While designing a Web site, think carefully about the URLs you
want to use. URLs are the entry points of your site. Think that
they may be bookmarked. If you create a link, you want to go to
another URL, and you want a page to be generated. That page may be
the default page for the URL (the one you get when you go back
to a bookmarked page), or another page, that depends on the precise
link or form you used to go to that URL (link to a coservice,
or page depending on post data).
Sometimes, you want that clicking
a link or submitting a form does something without changing the URL.
You can do this using //non-attached coservices// (see below).



>> <<|encadre>>
====Non-attached coservices


Non-attached coservices are coservices that are not attached to an URL path.
Service identification is performed only according to the coservice
identifier, whatever be the path.
When you point a link or a form towards such a service, the URL path 
and the main parameters do not change.
The parameters of the non-attached coservice are sent as a special parameters.

As for attached coservices, there are GET and POST versions,
and each of them may be named or anonymous.

To create a non-attached coservice, use
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALcoservice'"|<<span class="code"|Eliom_services.coservice'>>>> or
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpost_coservice'"|<<span class="code"|Eliom_services.post_coservice'>>>>
(note the "prime" at the end). <<span class="wip"|find better function names?>>
POST non-attached coservices are really useful if you want a
link or form to be present on every page but you don't want the
URL to change. Very often, non-attached POST coservices are
used with //actions// or //redirections//.

Here is one simple example. Suppose you wrote a function
<<span class="code"|remove>> to remove one piece of data from a database
(taking an identifier of the data).
If you want to put a link on your page to call this function
and redisplay the page, just create an action on a non-attached coservices
like this:

<<code language="ocaml"|let remove_action =
  Eliom_output.Action.register_post_coservice'
    ~post_params:(Eliom_parameters.int "id")
    (fun () id -> remove id)
>>
  
Then wherever you want to add a button to do that action
(on data <<span class="code"|id>>), create a form like:
  
<<code language="ocaml"|Eliom_output.Xhtml5.post_form remove_action
  (fun id_name ->
     Eliom_output.Xhtml5.int_input
       ~input_type:`Hidden ~name:id_name ~value:id ();
     Eliom_output.Xhtml5.string_input
       ~input_type:`Submit ~value:("remove "^string_of_int id) ())
>>

===Scope of services===

By default, services and coservices are accessible to anybody.
It is possible to restrict the //scope// of a service,
to make it available only to a session or a client side process,
or a group of sessions (see chapter * * for more information on scopes).

The same service can be registered with several scopes.
This makes possible for example to generate custom services for a specific user.
Eliom will try to find the service by trying, in that order:
* scope client-side process,
* scope session,
* scope group of session
* global scope.

If the service has not been found, and if it is a
<<span class="wip"|anonymous?>> coservice, it will then try the fallback,
in the same scoping order.

To set the scope of a service registration, add the optional
parameter {{{~scope}}} to the {{{register}}} function, that may take
value from the type
{{{[ `Global | `Session_group | `Session | `Client_process ]}}}.


===Examples===

The most commonly used services are:

* Main services (GET or POST) (global scope) for public
pages.
* GET attached coservices in session service table to make the
browser's "back" button turn back in the past of the interaction with the user,
and to allow several tabs on different versions of the same page
(several steps interaction).
* Actions registered on POST named non-attached coservices
to make an effect
on the server, from any page, and without changing the URL
(connection/disconnection for example).

Here is a list of frequent Web interaction issues
and the solution Eliom provides to solve them.
;Display the result of a search
:Use a coservice (anonymous, with timeout) 
in the session service table.
;Keep information about the session (name of the user~ ...)
:Use eliom references (scope {{{`Session}}}), see chapter * * .
;A connection or disconnection box on each page of your site
:Use actions registered on named non-attached coservices to set or
 remove data from a session data table.
;Add something in a shopping basket
:Use an action registered on a non-attached coservice,
with the names of the items as parameters. The action saves the shopping
basket in an eliom reference (scope {{{`Session}}}).
Thus, the shopping basket will remain
even if the user pushes the back button of his browser.
;Book a ticket (in several steps)
:Each step creates new (GET) coservices (with or without
parameters, all attached to the service displaying the main
booking page)
according to the data entered by the user. These
coservices are registered with scope {{{`Session}}} (with a timeout for
the whole session or for each of them). Thus the user can go back
to a previous state, or keep several proposals on differents
tabs before choosing one.
;...
://Help us to complete this list by giving your examples or
asking questions about other cases! Thank you!//
;



===@@id="p2detailsonserviceregistration"@@Details on service registration===

<<div class="encadre"|

*All services created during initialisation must be registered
(with global scope) during the initialisation phase of your module.
If not, the server will not start (with an error message in the logs).
This will prevent broken links.

* Services may be registered only during the initialisation phase of the
server (while reading site configuration) or while processing a request,
because Eliom must know the information about the site. Be very careful
about this if you want to use static linking (see chapter * * for more
information on static linking).

* All services (but not coservices) must be created in a module loaded
inside a <<span class="code"|<host>>> tag of the configuration file.
It is not possible to possible for modules loaded inside
<<span class="code"|<extension>>> or <<span class="code"|<library>>>.

* If you create new main services dynamically,
you will dynamically create new URLs!
This may be dangerous as they will disappear if you stop the server.
Be very careful to re-create these URLs when you relaunch the server,
otherwise, some external links or bookmarks will be broken!\\
The use of that feature is discouraged for coservices
without timeout, as such coservices will be available only until the end
of the server process (and it is not possible to re-create them with the
same key).

*Do not register twice the same service with scope global,
and do not replace a service
by a directory (or vice versa). If this happens during the
initialisation phase, the server won't start.
If this happens after, it will be ignored (with a warning in the
logs).

*GET coservices (without POST parameters) can be registered
only with a main service without GET/POST parameters as fallback.
But it may be a
[[manual/dev/services#p3preapplied|//preapplied//]]
service (see below).

*Services with POST parameters (main service or coservice)
can be registered with a (main or co) service without POST
parameters as fallback.
*The registration of (main) services must be completed before
the end of the loading of the module. It is not possible to launch
a (Lwt) thread that will register a service later, as
registering a service needs access to config file
information (for example the directory of the site).
If you do this, the server will raise
<<ocsigendoc version="dev" file="Eliom_common.html" fragment="EXCEPTIONEliom_function_forbidden_outside_site_loading"|<<span class="code"|Eliom_common.Eliom_function_forbidden_outside_site_loading >>>>
most of the time,
but you may also get unexpected results (if the thread is executed
while another site is loaded).
If you use threads in the initialization phase of your module
(for example if you need information from a database),
use <<ocsigendoc version="dev" file="Lwt_unix.html" fragment="VALrun"|<<span class="code"|Lwt_unix.run>>>> to wait the end of the thread.
>><<|encadre>>


==Other features==

===Secure services


You may want to impose HTTPS for some of your services.
 To do that, use the optional parameter <<span class="code"|~https:true>>
 while creating your service.

It is also possible to ask for HTTPS while creating a link or
a form (using the optional parameter <<span class="code"|~https:true>>).
But it is never possible to make an http link towards an https service,
even if you request it.

Warning: if the protocol needs to be changed (from HTTP to HTTPS
or vice versa), Eliom will generate absolute URLs.
The host name and port numbers are guessed from the IP and the 
configuration by default, but it is recommended to specify them
in the configuration file. For example:

<<div class="pre"|<host hostfilter="*.org" defaulthostname="www.mywebsite.org"
defaulthttpport="8080" defaulthttpsport="4433">
  ...
</host>
>>



===Timeouts for coservices


It is possible to put timeouts on coservices using
the optional parameter <<span class="code"|?timeout>> of functions
<<span class="code"|coservice>>,
<<span class="code"|coservice'>>, etc.
Note that session coservices cannot survive after the end of the session.
Use this if you don't want your coservice to be available during all the
session duration. For example if your coservice is here to show the
results of a search, you probably want it to be available only for
a short time. The following example shows a coservice with timeout
registered with scope {{{`Session}}}.

<<code language="ocaml"|let timeout = service ["timeout"] unit ()

let _ =
  let page () () =
    let timeoutcoserv =
      Eliom_output.Xhtml5.register_coservice
        ~scope:`Session
        ~fallback:timeout
        ~get_params:unit
        ~timeout:5.
        (fun _ _ ->
           Lwt.return
             (html
               (head (title (pcdata "Coservices with timeouts")) [])
               (body [p
                 [pcdata "I am a coservice with timeout."; br ();
                  pcdata "Try to reload the page!"; br ();
                  pcdata "I will disappear after 5 seconds of inactivity." ];
                 ])))
    in
    Lwt.return
      (html
        (head (title (pcdata "Coservices with timeouts")) [])
        (body [p
          [pcdata "I just created a coservice with 5 seconds timeout."; br ();
           a timeoutcoserv [pcdata "Try it"] (); ];
          ]))
  in
  Eliom_output.Xhtml5.register timeout page
>>
  
[[site:tuto/timeout| See this example here]].
  
  


===Disposable coservices
  
  
It is possible to set a limit to the number of uses of
  (attached or non-attached) coservices. Just give the maximum number
  of uses with the optional <<span class="code"|?max_use>> parameter while
  creating your coservices. Example

<<code language="ocaml"|let disposable = service ["disposable"] unit ()

let _ = register disposable
(fun () () ->
      let disp_coservice =
        coservice ~max_use:2 ~fallback:disposable ~get_params:unit ()
      in
      register ~scope:`Session ~service:disp_coservice
        (fun () () ->
          return
            (html
              (head (title (pcdata "")) [])
              (body [p [pcdata "I am a disposable coservice";
                        br ();
                        a disp_coservice [pcdata "Try me once again"] ()]]))
        );
      return
        (html
          (head (title (pcdata "")) [])
          (body [p [(if Eliom_request_info.get_link_too_old ()
                    then pcdata "Your link was outdated. I am the fallback. I just created a new disposable coservice. You can use it only twice."
                    else
                    pcdata "I just created a disposable coservice. You can use it only twice.");
                    br ();
                    a disp_coservice [pcdata "Try it!"] ()]])))
>>
  
[[site:tuto/disposable| Try it]].





===@@id="p3csrf"@@CSRF-safe services

Eliom implements a protection against CSRF attacks.

====What is CSRF?====

CSRF means //Cross Site Request Forgery//.
Here is an explanation from Wikipedia:

For example, one user, Bob, might be browsing a chat forum where another user, 
Mallory, has posted a message. Suppose that Mallory has crafted an HTML image 
element that references a script on Bob's bank's website (rather than an image 
file), e.g.,\\
{{{<img src="http://bank.example/withdraw?account=bob&amount=1000000&for=mallory">}}}\\
If Bob's bank keeps his authentication information in a cookie, and if the 
cookie hasn't expired, then the attempt by Bob's browser to load the image 
will submit the withdrawal form with his cookie, thus authorizing a 
transaction without Bob's approval.

====Solution with Eliom <= 1.2====

There is an easy way to protect a service from such attacks with Eliom 1.2:
just create a new anonymous coservice with timeout each time you display the 
form. Thus, a new token will be created for each form and no service will
answer if you do not send it (or more precisely the fallback will do).


====CSRF-safe services====

In order to simplify this, Eliom add this possibility:
*When creating a new coservice, you can give the optional ~csrf_safe 
parameter
*If this parameter is true, actual registration of the service will be 
delayed and performed each time a form is created towards this coservice

Example:
<<code language="ocaml"|
let csrfsafe_example =
  Eliom_services.service
    ~path:["csrf"]
    ~get_params:Eliom_parameters.unit
    ()

let csrfsafe_example_post =
  Eliom_services.post_coservice
    ~csrf_safe:true
    ~csrf_state_name:"csrf"
    ~csrf_secure_session:true
    ~timeout:10.
    ~max_use:1
    ~https:true
    ~fallback:csrfsafe_example
    ~post_params:Eliom_parameters.unit
    ()

let _ =
  let page () () =
    let l3 = Eliom_output.Xhtml.post_form csrfsafe_example_post
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"Click" ()]]) ()
    in
    Lwt.return
      (html
       (head (title (pcdata "CSRF safe service example")) [])
       (body [p [pcdata "A new coservice will be created each time this form is displayed"];
              l3]))
  in
  Eliom_output.Xhtml.register csrfsafe_example page;
  Eliom_output.Xhtml.register csrfsafe_example_post
    (fun () () ->
       Lwt.return
         (html
            (head (title (pcdata "CSRF safe service")) [])
            (body [p [pcdata "This is a CSRF safe service"]])))

>>


If you register the service with global scope, 
the CSRF safe service will be available for everybody.
But the actual (delayed) registration will take place with
a restricted scope (default: {{{`Session}}}),
described by {{{?csrf_scope}}}, {{{?csrf_state_name}}} and
{{{?csrf_secure}}} (corresponding to {{{?scope}}}, {{{?state_name}}} and
{{{?secure}}}).

If you use {{{register ~scope:`Session}}}, 
the coservice will be available only for one session.
The actual registration will take place in the same session table,
described by {{{?csrf_state_name}}} and {{{?csrf_secure}}}.
In that case, the parameters
{{{?state_name}}} and {{{?secure}}} of {{{register}}}
must be exactly the same.



===@@id="p3preapplied"@@Pre-applied services
  
  
Services or coservices with GET parameters can be preapplied
 to obtain a service without parameters. Example:

  

  
<<code language="ocaml"|let preappl = Eliom_services.preapply coucou_params (3,(4,"cinq"))

>>

  
 It is not possible to register something on a preapplied service,
 but you can use them in links or as fallbacks for coservices.

  


===@@id="p3preapplied"@@Void coservices
  
  
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALvoid_coservice'"|<<span class="code"|Eliom_services.void_coservice'>>>>
is a special non-attached action, with special behaviour:
it has no parameter at all, even non-attached parameters.
Use it if you want to make a link to the current page
without non-attached parameters.
It is almost equivalent to a POST non-attached coservice without POST
parameters, on which you register an action that does nothing,
but it is using GET method, so that you can use it with
<<span class="code"|<a>>> links, not only forms.
Example:

<<code language="ocaml"|
Eliom_duce.Xhtml.a
  ~service:Eliom_services.void_coservice'
  {{ "cancel" }}
  ()
>>

There is also 
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALhttps_void_coservice'"|<<span class="code"|Eliom_services.https_void_coservice'>>>>
(same, but forces use of HTTPS),
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALvoid_hidden_coservice'"|<<span class="code"|Eliom_services.void_hidden_coservice'>>>>, and
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALhttps_void_hidden_coservice'"|<<span class="code"|Eliom_services.https_void_hidden_coservice'>>>>. "Hidden" means that they keep GET non attached parameters.

See an example of use in chapter * * section * * (connection of users with
session groups).


===@@id="p3infofallbacks"@@Get information on what succeeded before the service===

The function
<<ocsigendoc version="dev" file="Eliom_request_info.html" fragment="VALget_link_too_old"|<<span class="code"|Eliom_request_info.get_link_too_old>>>>
returns <<span class="code"|true>> if the coservice called has not been found.
In that case, the current service is the fallback.

The function
<<ocsigendoc version="dev" file="Eliom_request_info.html" fragment="VALget_expired_service_sessions"|<<span class="code"|Eliom_request_info.get_expired_service_sessions>>>>
returns the list of names of service sessions expired 
for the current request.

It is also possible to send other information to the service occuring after
an action, by using //Eliom references// with scope {{{`Request}}}
(see chapter * *).
