=Writing a client/server Eliom application=

<<div class="wip"|**Work in progress**>>

This chapter and the two following ones are an overview of the features
the Ocsigen framework brings to build Web applications.
They will allow you to understand the philosophy of Eliom
(the Web programming framework in OCaml), and are also a good
starting point to understand other libraries of the Ocsigen project: Lwt, Macaque, etc.

Theses  chapters do  not  aim at  exhaustiveness  but many  references
towards other  chapters are made all  along the text, so  that you can
learn the concepts in detail if you want to.

We assume the reader has a good knowledge of the Objective Caml language.

The present chapter is a tutorial for writing a small client/server
collaborative drawing application. You will learn how to:
* Create new //services//
* Output //valid HTML//
* Send //OCaml code// to be executed //on the client//
* Call //Javascript methods// from OCaml
* Catch //mouse events//
* //Communicate// with the server, in both directions
* Use the //O'Closure// widget library
* Create services with //non-HTML output//

The next chapter is devoted to server side programming.
We will create a new Web site with several pages and user connection. In this chapter, yo will learn how to:
* Create a //link// towards another service
* Create //forms//
* Register //session data// or //session services//
* Create services performing //actions// (with no output)
* Register dynamically new services (//continuation based// Web programming)


The third chapter in an overview of miscellaneous Eliom features. We will mix the application from the first chapter
to the one of the second chapter to produce a multi-user
collaborative drawing application with user connection.
In this chapter, yo will learn how to:
* Use the usual Web interaction (links, forms,~ …) together 
with a client side program.
* Add //sounds or videos// in your application
* Change page //without stopping the client side program//
* Connect with external accounts (//openID//) <<span class="wip"|???>>
* Add an Atom stream



If you are not interested in client-side programming you can safely skip
most of the first chapter (read at least the first section, that explains
the basics). Conversely, if you are not interested in usual Web interaction,
with sessions links, and forms, you can skip the second chapter.

But keep in mind that one of the key feature of Eliom is that it allows to mix
very easily usual Web interaction (URLs, forms, links, bookmarks, back button)
with very dynamic client side features. In particular, the client side
program **does not stop** when the user click a link, send a form, or
press the back button  and the user still can save bookmarks on pages!
This opens up a wide field of new possibilities,
and should allow the emergence of a new kind of Web applications.




==@@id="basics"@@ Basics ==

In this first section, we will build a collaborative drawing application. It is a client/server Web application displaying an area where users can draw using the mouse, and see what other users are drawing.

===My first page===
<<div class="concepts"|Services\\Configuration file\\Static validation of HTML>>
Our Web application consists in one single page for now.
Let's start by creating a very basic page.
We define the service that will implement this page by the following declaration: 
<<code language="ocaml"|open Lwt
open XHTML5.M
open Eliom_services
open Eliom_parameters
open Eliom_output.Xhtml

let main_service =
  register_service ~path:["graff"] ~get_params:unit
    (fun () () -> return (html (head (title (pcdata "")) [])
                               (body [h1 [pcdata "Graffiti"]])))>>

The same, written with fully qualified values (without {{{open}}}):
<<code language="ocaml"|let main_service =
  Eliom_output.Xhtml5.register_service ~path:["graff"] ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (XHTML5.M.html (XHTML5.M.head (XHTML5.M.title (XHTML5.M.pcdata "")) [])
                       (XHTML5.M.body [XHTML5.M.h1 [XHTML5.M.pcdata "Graffiti"]])))
>>

Copy one of the two pieces of code above in a file {{{graffiti.ml}}}, then compile it by typing:
{{{
ocamlfind ocamlc -thread -package ocsigen -c graffiti.ml
}}}
This will create a file called {{{graffiti.cmo}}}.

Take the configuration file provided [[/manual/dev/graffiti/graffiti1.conf|here]],
then run Ocsigen server with this configuration file:
{{{
ocsigen -c graffiti1.conf
}}}
Your page is now available at URL
<<span class="code"|~http:~/~/localhost:8080/graff>>.


<<div class="encadre"|====Services====
Unlike many other Web programming techniques (CGI, PHP,~ ...),
with Eliom, you don't write one file for each URL, but
a caml module (cmo or cma) for the whole Web site.

The <<ocsigendoc version="dev" file="Eliom_services.html"|<<span class="code"|Eliom_services>>>> module allows to create new entry points to
your Web site, called //services//. In general, services are
attached to an URL and generate a Web page.
Services are represented by OCaml values, on which
you must register a function that will generate a page.

The {{{~path}}} parameter corresponds to the URL where you want to attach
your service. It is a list of strings.
The value <<span class="code"|["foo"; "bar"]>> corresponds to the URL
  <<span class="code"|foo/bar>>.      \\
  <<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
  (that is: the default page of the directory <<span class="code"|dir>>).       
>>
<<div class="encadre"|====Configuration file====
Have a look to the configuration file.
It contains the configuration for Ocsigen server (port, log files,
extensions to be loaded, etc.), and something like:

<<div class="pre"|<host>
    <static dir="~///path_to///graffiti" />
    <eliom module="~///path_to///graffiti.cmo" />
</host>

>>

It tells the server that pages to be sent are:
* static files from the directory <<span class="code"|~///path_to///graffiti>>
if they exist,
* pages generated by the Eliom application {{{graffiti.cmo}}} otherwise.

>>

<<div class="encadre"|====Static validation of HTML====
There are several ways to create pages for Eliom. 
You can generate pages as strings (as in other Web frameworks).
But we prefer checking that the HTML will be correct at compile time.
Eliom provides several modules to do that, either using OcamlDuce (if you
have it installed) or using OCaml's polymorphic variants.
This tutorial is using the second solution, using the module
<<ocsigendoc version="dev" file="Eliom_output.Xhtml5.html"|<<span class="code"|Eliom_output.Xhtml5>>>>. This module defines a construction function
for each HTML5 tag.

//Note that it is also possible to use the usual HTML syntax.
See [[/manual/dev/html|here]] for more information.//

Typing of HTML with <<ocsigendoc version="dev" file="XHTML5.M.html"|<<span class="code"|XHTML5.M>>>> and <<ocsigendoc version="dev" file="Eliom_output.Xhtml.html"|<<span class="code"|Eliom_output.Xhtml>>>>
is very strict and compels you to respect HTML5 standard
(with some limitations). For example if you write:
  
<<code language="ocaml"|(html
   (head (title (pcdata "")) [pcdata ""])
   (body [pcdata "Hallo"]))
>>
  
You will get the following error message:
{{{
Error: This expression has type ([> `PCDATA ] as 'a) XHTML5.M.elt
       but an expression was expected of type Xhtml5types.head_content_fun XHTML5.M.elt
       Type 'a is not compatible with type Xhtml5types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ] 
       The second variant type does not allow tag(s) `PCDATA
}}}

  
<<span class="code"|Xhtml5types.head_content_fun>>
is the type of content allowed inside
<<span class="code"|<head>>>.
You see that {{{`PCDATA}}} (i.e. raw text) is not in this polymorphic
variant type.

**Other example:** In XHTML5, some tags cannot be empty. For example
<<span class="code"|<table>>> must contain at least one row.
To enforce this, the <<ocsigendoc version="dev" file="XHTML5.M.html" fragment="VALtable"|<<span class="code"|XHTML5.M.table>>>> function takes two parameters:
the first one is the first row, the second one is a list
containing all the other rows.
(same thing for <<span class="code"|<tr>>> <<span class="code"|<form>>>
<<span class="code"|<dl>>> <<span class="code"|<ol>>> <<span class="code"|<ul>>>
<<span class="code"|<dd>>> <<span class="code"|<select>>> ...)
This forces the user to handle the empty list case specially and thus make
the output conform to the recommendation from the W3C.

//Strict typing of HTML may seem arduous at first sight,
but in fact it is very easy to get used to it.
It actually saves a huge amount of
debugging time as you will ever have to bother about the validity of
pages afterwards.//

A more detailed introduction to <<span class="code"|XHTML5.M>> is available
[[/manual/dev/html|here]] and
<<ocsigendoc version="dev" file="XHTML5.M.html"|here>>.

>>

<<div class="encadre"|====Lwt====
    **Important warning:** All the functions you write must be written
    in collaborative manner using Lwt. Lwt is a very convenient way to
    implement concurrent programs in OCaml, which is now widely used
    even for applications not related to Ocsigen.

    For now we will just use the {{{Lwt.return}}} function as above.
    We will come back later on Lwt programming.
    You can also have a look at the [[wiki(21):|Lwt programming guide.]]
>>

===Execute parts of the program on the client===
<<div class="concepts"|Service sending an application <<span class="new"|New in 1.90!>>\\
Client and server code <<span class="new"|New in 1.90!>>\\
Compiling a Web application with server and client parts <<span class="new"|New in 1.90!>>\\
Calling Javascript methods with Js_of_ocaml <<span class="new"|New in 1.90!>>>>
To create our first service, we used the function
{{{Eliom_output.Xhtml5.register_service}}}, as we wanted to return HTML5.

But actually we want our service to send an Eliom application.
To do that, we will create our own registration module by using the
functor {{{Eliom_output.Eliom_appl}}}:

<<code language="ocaml"|open XHTML5.M

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params = Eliom_output.default_appl_params
    end)
>>

It is now possible to use this module for registering our main service:
<<code language="ocaml"|let main_service =
  My_appl.register_service ~path:[""] ~get_params:Eliom_parameters.unit
    (fun () () -> Lwt.return [h1 [pcdata "Graffiti"]])
>>

<<div class="encadre"|==== The {{{Eliom_output.Eliom_appl}}} functor ====
The {{{Eliom_output.Eliom_appl}}} we used here takes as parameters
the information about the application:
* The application name
* The parameters of the application (here the defaults)

Note that the function implementing the service now returns only the
content of the page, and not the full page. The header is created
automatically from the information you gave to the functor
(this is customizable).

HTML is created using the {{{XHTML5.M}}} module, as before.
>>

We now want to add some OCaml code to be executed by the browser.
We start by a very basic program, that will display a message to the user
by calling the Javascript function {{{alert}}}. We add the following lines
to the program:

<<code language="ocaml"|{client{
  let _ = Dom_html.window##alert(Js.string "Hello")
}}
>>

As you can see, we are using a syntax extension to distinguish
between server and client code in the same file.
Put the [[/manual/dev/Makefile|default Makefile]]
and the [[/manual/dev/graffiti/graffiti2.conf|new configuration file]]
in your directory. You may want to adapt the configuration file to set
the paths, especially the directory for static files. (To make things easier
for the tutorial, you can use your source directory but keep in mind
that it is not necessary (and sometimes dangerous) to put {{{.ml}}}
and {{{.cma}}}/{{{.cmo}}} in the static files directory!)

The default {{{Makefile}}} recognizes files using Eliom's syntax extension by
their extension {{{.eliom}}} (instead of {{{.ml}}}).
Put the new version of our program in a file {{{graffiti.eliom}}}
and compile it by typing:
{{{
make
}}}
This will generate a file called {{{graffiti.cma}}}
and another one called {{{graffiti.js}}}. The latter //must be placed in the
static file directory//.

Now run Ocsigen server:
{{{
ocsigen -c graffiti2.conf
}}}
Your page is now available at URL
<<span class="code"|~http:~/~/localhost:8080/>>.
It should open an alert box. If not check that the static file directory 
in the configuration file is correct.

<<div class="encadre"|==== Client side code ====
Eliom's syntax extension implements four kinds of quotations:
* {{{ {client{ ... }} }}} for client side code
* {{{ {server{ ... }} }}} (optional) for server side code
* {{{ {shared{ ... }} }}} for code that will be used both for the server and the client
* {{{ {{ ... }} }}} for client side code in expressions (see later)

The default Makefile we automatically split the code, compile the server
part as usual, and compile the client part using {{{js_of_ocaml}}},
to create a Javascript file.
>>

<<div class="encadre"|==== Js_of_ocaml ====
The client side parts of the program are compiled to Javascript by
Js_of_ocaml. It is a compiler from Ocaml bytecode to Javascript.
It is easy to bind javascript libraries to call Javascript functions
from OCaml programs. In the example, we are using the {{{Dom_html}}}
module, which is a binding to allow the manipulation of an HTML page. <<span class="wip"|See the interface of the {{{Dom_html}}} module **here**.>>

Js_of_ocaml is using a syntax extension to call Javascript methods:
* {{{obj##m(a, b, c)}}} to call the method {{{m}}} of object {{{obj}}}
with parameters {{{(a, b, c)}}}
* {{{obj##m}}} to get a property
* {{{obj##m <- e}}} to set a property
* {{{jsnew constr (e1, ..., en)}}} to call a Javascript constructor

Find more information about Js_of_ocaml in
[[wiki(30):/lib/overview|Js_of_ocaml's manual]].
>>

<<div class="wip"|**Warning** The default Makefile is still experimental. It does not support {{{.mli}}} files and some error messages concern temporary files instead of the original ones. Any contribution appreciated.>>

==@@id="graffiti"@@ Collaborative drawing application ==

===Drawing on a canvas===
<<div class="concepts"|Canvas>>
To draw something on the page, we will use an HTML5 canvas.
We define a client side function called {{{draw}}} to draw a line.
Then when the service is called, we want to add dynamically a canvas
to the page, and draw a line.

Here is the (full) new version of the program:
<<code language="ocaml"|{shared{
  open XHTML5.M
  let width = 700
  let height = 400
}}

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params = Eliom_output.default_appl_params
    end)

{client{
  let draw ctx (color, size, (x1, y1), (x2, y2)) =
    ctx##strokeStyle <- (Js.string color);
    ctx##lineWidth <- float size;
    ctx##beginPath();
    ctx##moveTo(float x1, float y1);
    ctx##lineTo(float x2, float y2);
    ctx##stroke()
}}

let main_service =
  My_appl.register_service ~path:[""] ~get_params:Eliom_parameters.unit
    (fun () () ->
       Eliom_services.onload
         {{
           let canvas = Dom_html.createCanvas Dom_html.document in
           let ctx = canvas##getContext (Dom_html._2d_) in
           canvas##width <- width; canvas##height <- height;
           ctx##lineCap <- Js.string "round";

           Dom.appendChild Dom_html.document##body canvas;

           draw ctx ("#ffaa33", 12, (10, 10), (200, 100))
         }};
      Lwt.return [h1 [pcdata "Graffiti"]])
>>

As we want to draw the canvas only on that page and not on the other (future)
pages of the site, we use the function {{{Eliom_services.onload}}} to
describe the code to be executed when this service in called.


<<div class="encadre"|====  ====
Note that we use the function {{{Js.string}}} from Js_of_ocaml's library
to convert OCaml string into JS strings.
>>

===Single user drawing application===
<<div class="concepts"|Mouse events with arrows <<span class="new"|New in 1.90!>>>>
We now want to catch mouse events to draw lines with the mouse.
To do that, we will use the <<span class="wip"|very experimental>>
{{{Event_arrows}}} module from Js_of_ocaml's library.

Add
<<code language="ocaml"|  open Event_arrows
>>
in client side code (for example just before the draw function)
and replace the line
<<code language="ocaml"|           draw ctx ("#ffaa33", 12, (10, 10), (200, 100))
>>
by the following piece of code:
<<code language="ocaml"|          let x0, y0 = Dom_html.elementClientPosition canvas in
          let x = ref 0 and y = ref 0 in
          let set_coord ev = x := ev##clientX - x0; y := ev##clientY - y0 in
          let compute_line ev = 
            let oldx = !x and oldy = !y in
            set_coord ev;
            ("#ff9933", 5, (oldx, oldy), (!x, !y))
          in
          let line ev = draw ctx (compute_line ev) in
          ignore (run (mousedowns canvas
                         (arr (fun ev -> set_coord ev; line ev)
                          >~>> first [mousemoves Dom_html.document (arr line);
                                     mouseup Dom_html.document >~>> (arr line)])) ());
>>

Compile, run the program and draw!

We use to references {{{x}}} and {{{y}}} to record the last mouse position.
The function {{{set_coord}}} updates these references from mouse event data.
The function {{{compute_line}}} computes the coordinates of a line from
old coordinates to the event data sent as parameter.

The event handling must be read as follow:\\
For each mousedown event on the canvas, do {{{set_coord}}} then {{{line}}}
(this will draw a dot), then behave as the first of the two following
lines to terminate:
* For each mousemove event on the document, call {{{line}}} (never terminates)
* If there is a mouseup event on the document, call {{{line}}}.

<<div class="encadre"|==== Handling events with arrows ====
The module {{{Event_arrows}}} allows to define event listeners very easily
(using arrows). An arrow from {{{'a}}} to {{{'b}}}
has type {{{('a, 'b) Event_arrows.t}}}. The operator {{{>>>}}} is used
to bind the output of an arrow to the input of the following one.

For example {{{(mouseup Dom_html.document)}}} is an arrow from
{{{unit}}} to {{{Dom_html.mouseEvent Js.t}}}.

The combinator {{{arr}}}
transforms a function of type {{{'a -> 'b}}} into an arrow of type
{{{('a, 'b) Event_arrows.t}}}. There is also a combinator {{{lwt_arr}}} to
transform a function of type {{{'a -> 'b Lwt.t}}} into an arrow of type
{{{('a, 'b) Event_arrows.t}}}.

Combinators like {{{mousedowns}}} or {{{mousemoves}}} (ending by "s")
take as parameters the target of the event and an arrow that will be called
each time the event occures.

The function
{{{
Event_arrows.run :('a, unit) t -> 'a -> canceller
}}}
sets up an event handler. It returns a "canceller" that you can use to cancel
it:
{{{
let c = Event_arrows.run ( ... ) in
...
Event_arrows.cancel c
}}}

The combinator {{{first}}} takes a list of arrows and behaves as the first
to terminate. All the other arrows in the list are cancelled.
>>

<<div class="wip"|**Warning** Event arrows will evolve in the near future.>>

===Collaborative drawing application===
<<div class="concepts"|Client server communication <<span class="new"|New in 1.90!>>>>
We now want:
* To send the coordinates to the server when the user draw a line
* To dispatch the coordinates to all connected users

<<div class="wip"|To do this we use the experimental {{{Eliom_channels}}}
module, that will evolve in the near future. More explanation when this
module is updated.>>

<<code language="ocaml"|let e_up = Eliom_channels.Up.create ~name:"graf" ~level:`Site
  (Eliom_parameters.caml "line" : ((string * int * 
                                      (int * int) * (int * int)), 'aa, 'aaa) Eliom_parameters.params_type)
let e_up_real = Eliom_channels.Up.react_event_of_up_channel e_up
>>

<<code language="ocaml"|    (fun g () ->
       let e_down = Eliom_channels.Down.of_react ~buffer_size:100 e_up_real in
       Eliom_services.onload
         {{
           let e_up = \(e_up) in
           let e_down = \(e_down) in
           ...
>>

To send the coordinates to the server, we just replace the function {{{line}}}
by:
<<code language="ocaml"|          let line ev = 
            let v = compute_line ev in
            draw ctx v;
            e_up v
>>

<<code language="ocaml"|           ignore (React.E.map (draw ctx) e_down);
>>
Now you can try the program using two browser windows to see that the lines
are drawn on both.

<<div class="encadre"|==== Antiquotations: Using server side values in client code ====
<<div class="wip"|//soon//>>
>>
<<div class="encadre"|==== Communication channels ====
<<div class="wip"|//soon//>>
>>

<<div class="wip"|The full code for that version can be donwloaded **here** //(soon)//>>


<<div class="wip"|**Warning** The syntax of anti-quotations may change in the future>>

===Color and size of the brush===
<<div class="concepts"|Widgets with O'Closure <<span class="new"|New in 1.90!>>>>
In this section, we will add two widgets, taken from the O'Closure widget
library. We need to add some stylesheets and one JS file in the headers of
our page. We do this by modifying the {{{params}}} value given to the
{{{Eliom_output.Eliom_appl}}} functor:
<<code language="ocaml"|      let params =
        {Eliom_output.default_appl_params with
           Eliom_output.ap_title = "Graffiti";
           Eliom_output.ap_headers_before =
            [
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./static/css/graffiti.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./static/css/common.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./static/css/hsvpalette.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./slider.css")
                ();
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js")
                   ] (XHTML5.M.pcdata "");
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "./graffiti_req.js")
                   ] (XHTML5.M.pcdata "");
            ];
        }
>>

<<div class="wip"|Take the stylesheets and images needed here.>>
The file {{{graffiti_req.js}}} is generated by the Makefile according
to the {{{graffiti.js}}} to load dynamically the Google Closure files
we need.

<<code language="ocaml"|          (* Size of the brush *)
          let slider = jsnew Goog.Ui.slider(Js.null) in
          slider##setMinimum(1.);
          slider##setMaximum(80.);
          slider##setValue(10.);
          slider##setMoveToPointEnabled(Js._true);
          slider##render(Js.some Dom_html.document##body);
          
          (* The color palette: *)
          let pSmall = 
            jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
				     Js.some (Js.string "goog-hsv-palette-sm"))
          in
          pSmall##render(Js.some Dom_html.document##body);
>>
Finally, replace last line of the function {{{compute_line}}} by;
<<code language="ocaml"|            let color = Js.to_string (pSmall##getColor()) in
            let size = int_of_float (Js.to_float (slider##getValue())) in
            (color, size, (oldx, oldy), (!x, !y))
>>

<<div class="encadre"|====O'Closure====
O'Closure is a Js_of_ocaml binding for the Google Closure widget library
(used for example in GMail, Google calendar or Google Maps).
You can use it for building complex user interfaces for your Eliom application.
The full documentation is available [[wiki(33):|here]].
>>

<<div class="wip"|//Fix the directories for static files and Google Closure//>>


===Sending the initial image===
<<div class="concepts"|Services sending other data types>>
To finish, we want to save the current drawing on server side and send the 
current image when a user arrives. To do that, we will use the
[[http://www.cairographics.org/cairo-ocaml/|Cairo binding]] for OCaml.

The {{{draw_server}}} function below in the equivalent of the {{{draw}}}
function on server side (in an ideal world, we would have a common interface
for canvas so that we could share the code).
The {{{image_string}}} function outputs the PNG image in a string.
<<code language="ocaml"|
let draw_server, image_string = 
  let surface = Cairo.image_surface_create Cairo.FORMAT_ARGB32 ~width ~height in
  let ctx = Cairo.create surface in
  ((fun ((color : string), size, (x1, y1), (x2, y2)) ->

    (* Set thickness of brush *)
    Cairo.set_line_width ctx (float size) ;
    Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
    Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
    let red, green, blue =  rgb_from_string color in
    Cairo.set_source_rgb ctx ~red ~green ~blue ;

    Cairo.move_to ctx (float x1) (float y1) ;
    Cairo.line_to ctx (float x2) (float y2) ;
    Cairo.close_path ctx ;
    
    (* Apply the ink *)
    Cairo.stroke ctx ;
   ),
   (fun () ->
     let b = Buffer.create 10000 in
     (* Output a PNG in a string *)
     Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
     Buffer.contents b
   ))
>>

Now we define a service that will send the picture:
<<code language="ocaml"|
let imageservice =
  Eliom_output.Text.register_service
    ~path:["image"]
    ~get_params:Eliom_parameters.unit
    (fun () () -> Lwt.return (image_string (), "image/png"))
>>

<<div class="encadre"|====Eliom_output====
The module {{{Eliom_output}}} defines several modules with registration
functions for several data types. We have already seen 
{{{Eliom_output.Xhtml5}}} and {{{Eliom_output.Eliom_appl}}}.
The module {{{Eliom_output.Text}}} sends any text output.
The handler function must return a pair with the string and the content-type.

There are also several other output modules, for example:
* {{{Eliom_output.Files}}} to send static files
* {{{Eliom_output.Redirection}}} to create a redirection towards another page
* {{{Eliom_output.Any}}} to create services that choose themselves what
they want to send
* {{{Eliom_output.Caml}}} to send marshaled OCaml data to be used in a
client side program
* {{{Eliom_output.Action}}} to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.

>>

We now want to load the initial image once the canvas is created.
Add the following lines just between the creation of the canvas
and the creation of the slider:
<<code language="ocaml"|           (* The initial image: *)
           let img = Dom_html.createImg Dom_html.document in
           img##alt <- Js.string "canvas";
           img##src <- Js.string (Eliom_output.Xhtml5.make_string_uri ~service:imageservice ());
           let image_loaded, image_loaded_w = Lwt.wait () in
           img##onload <- Dom_html.handler (fun ev -> Lwt.wakeup image_loaded_w (); Js._false);

           ignore (image_loaded >|= fun () -> ctx##drawImage(img, 0., 0.));
>>

<<div class="wip"|//Add cairo in the Makefile//>>

<<div class="wip"|//Simplify this (write this with Xhtml5 and higher level interface?) and explain {{{Lwt.wait}}} etc.//>>


The first version of the program is now complete.
<<div class="wip"|//The full source code can be found **here**.//>>

<<div class="exercices"|
====Exercices====
* Add an O'Closure button to make possible to download the
current image and save it to the hard disk (reuse the service {{{imageservice}}}).
* Add an O'Closure button with a color picker to select a color from the drawing.  (Modify mouse events and use the function {{{Dom_html.pixel_get}}}).
>>
