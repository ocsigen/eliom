=Miscellaneous features=

<<div class="wip"|**Work in progress**>>

==Multi-user collaborative drawing application==

To turn our drawing application to a multi user one, we need to
refactor some parts. In particular, we need to be able to handle
separately different drawings. To do this, we will turn all global
variable, like the bus, in local ones.

===Split application into multiple files===

When an application grows, it start being usefull to split it in
multiple files. For sake of example, we will split graffiti into 4
files.

* {{{common.ml}}} wich will be part of both client and server,
containing shared types and declarations
* {{{client.ml}}} client only part of the application
* {{{server.ml}}} server only part of the application
* {{{graffiti.eliom}}} the only part where we need to include both client and server code

===={{{common.ml}}}====

It contains what was in {{{ {shared{ .. }} }}}
<<code language="ocaml"|type messages = (string * int * (int * int) * (int * int)) deriving (Json)

let width = 700
let height = 400>>

===={{{client.ml}}}====

It is almost the same code as what was enclosed in {{{ {client{ ... }} }}}
with the difference that what was previously in
{{{ Eliom_services.onload {{ }} }}} is now in the function, {{{ launch_client_canvas }}}.

<<code language="ocaml"|open Common open
Event_arrows

let draw ctx (color, size, (x1, y1), (x2, y2)) =
  ctx##strokeStyle <- (Js.string color);
  ctx##lineWidth <- float size;
  ctx##beginPath();
  ctx##moveTo(float x1, float y1);
  ctx##lineTo(float x2, float y2);
  ctx##stroke() >>

Since we want to be able to change page without restarting the
application, we can not add the canvas and the widgets directly to the
document as it would then stay at the botom of the page after page
change. We now append it to an element of the page that is newly
generated: {{{canvas_box}}}.

<<code language="ocaml"|let launch_client_canvas bus imageservice canvas_box =
  let canvas = Dom_html.createCanvas Dom_html.document in
  let ctx = canvas##getContext (Dom_html._2d_) in
  canvas##width <- width; canvas##height <- height;
  ctx##lineCap <- Js.string "round";

  (* The initial image: *)
  let img = Dom_html.createImg Dom_html.document in
  img##alt <- Js.string "canvas";
  img##src <- Js.string (Eliom_output.Xhtml5.make_string_uri ~service:imageservice ());
  img##onload <- Dom_html.handler (fun ev -> ctx##drawImage(img, 0., 0.); Js._false);

  Dom.appendChild canvas_box canvas;

  (* Size of the brush *)
  let slider = jsnew Goog.Ui.slider(Js.null) in
  slider##setMinimum(1.);
  slider##setMaximum(80.);
  slider##setValue(10.);
  slider##setMoveToPointEnabled(Js._true);
  slider##render(Js.some canvas_box);
  
  (* The color palette: *)
  let pSmall = 
    jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                             Js.some (Js.string "goog-hsv-palette-sm"))
  in
  pSmall##render(Js.some canvas_box);

  let x = ref 0 and y = ref 0 in
  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0 in
  let compute_line ev = 
    let oldx = !x and oldy = !y in
    set_coord ev;
    let color = Js.to_string (pSmall##getColor()) in
    let size = int_of_float (Js.to_float (slider##getValue())) in
    (color, size, (oldx, oldy), (!x, !y))
  in
  let line ev =
    let v = compute_line ev in
    let _ = Eliom_client_bus.write bus v in
    draw ctx v
  in
  let _ = Lwt_stream.iter (draw ctx) (Eliom_client_bus.stream bus) in
  ignore (run (mousedowns canvas
		 (arr (fun ev -> set_coord ev; line ev)
			      ~>>> first [mousemoves Dom_html.document (arr line);
					 mouseup Dom_html.document ~>>> (arr line)])) ())
>>

===={{{server.ml}}}====

It contains almost all the server part of the code.
<<code language="ocaml"|open XHTML5.M
open Common
open Lwt

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params =
	{ Eliom_output.default_appl_params with
	  
          Eliom_output.ap_headers_before =
            [
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/graffiti.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/common.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/hsvpalette.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/slider.css")
                ();
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js")
                   ] (XHTML5.M.pcdata "");
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "./graffiti_req.js")
                   ] (XHTML5.M.pcdata "");
            ];
	}
    end)
let rgb_from_string color = (* color is in format "#rrggbb" *)
  let get_color i = (float_of_string ("0x"^(String.sub color (1+2*i) 2))) /. 255. in
  try get_color 0, get_color 1, get_color 2 with | _ -> 0.,0.,0.
>>

The main difference is that the bus and the {{{image_string}}} are now local.
<<code language="ocaml"|let launch_server_canvas () =
  let bus = Eliom_bus.create Json.t<messages> in
  
  let draw_server, image_string =
    let surface = Cairo.image_surface_create Cairo.FORMAT_ARGB32 ~width ~height in
    let ctx = Cairo.create surface in
    ((fun ((color : string), size, (x1, y1), (x2, y2)) ->

      (* Set thickness of brush *)
      Cairo.set_line_width ctx (float size) ;
      Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
      Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
      let red, green, blue =  rgb_from_string color in
      Cairo.set_source_rgb ctx ~red ~green ~blue ;

      Cairo.move_to ctx (float x1) (float y1) ;
      Cairo.line_to ctx (float x2) (float y2) ;
      Cairo.close_path ctx ;
      
      (* Apply the ink *)
      Cairo.stroke ctx ;
     ),
     (fun () ->
       let b = Buffer.create 10000 in
       (* Output a PNG in a string *)
       Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
       Buffer.contents b
     ))
  in
  let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus) in
  bus,image_string

let graffiti_info = Hashtbl.create 0

let get_bus_image (name:string) =
  (* create a new bus and image_string function only if it did not exists *)
  try
    Hashtbl.find graffiti_info name
  with
    | Not_found ->
      let bus,image_string = launch_server_canvas () in
      Hashtbl.add graffiti_info name (bus,image_string);
      (bus,image_string)
>>

The main page now does launch the application. It only contains a
formulary to choose to wich drawing you want to go. The application is
launched by the {{{multigraffiti_service}}} service. It is registered
in {{{graffiti.eliom}}}.

<<code language="ocaml"|let main_service = Eliom_services.service ~path:[""]
  ~get_params:(Eliom_parameters.unit) ()
let multigraffiti_service = Eliom_services.coservice ~fallback:main_service
  ~get_params:(Eliom_parameters.string "name") ()

let choose_drawing_form () =
  My_appl.get_form ~service:multigraffiti_service
    (fun (name) ->
      [p [pcdata "drawing name: ";
          My_appl.string_input ~input_type:`Text ~name ();
          br ();
          My_appl.string_input ~input_type:`Submit ~value:"Go" ()
         ]])

let () = My_appl.register ~service:main_service
  ( fun () () ->
    Lwt.return [h1 [pcdata "Welcome to Multigraffiti"];
		choose_drawing_form ()])
>>

===={{{graffiti.eliom}}}====

Here is the code that mix client and server parts.

We first open the corresponding modules for each parts of the
application.

<<code language="ocaml"|{shared{
  open XHTML5.M
  open Common
}}
{client{
  open Client
}}
open Server
>>

<<code language="ocaml"|let graffiti_info = Hashtbl.create 0

let include_canvas (name:string) (canvas_box:[ Xhtml5types.div ] XHTML5.M.elt) =

  (* create a new bus and image_string function only if it did not exists *)
  let bus,image_string =
    try
      Hashtbl.find graffiti_info name
    with
      | Not_found ->
	let bus,imageservice = launch_server_canvas () in
	Hashtbl.add graffiti_info name (bus,imageservice);
	(bus,imageservice)
  in

  let imageservice =
    Eliom_output.Text.register_coservice'
      ~timeout:10.
      (* the service is available fo 10 seconds only, but it is long
	 enouth for the browser to do its request. *)
      ~get_params:Eliom_parameters.unit
      (fun () () -> Lwt.return (image_string (), "image/png"))
  in

  Eliom_services.onload
    {{
      launch_client_canvas %bus %imageservice %canvas_box
    }}
>>

{{{imageservice}}} is now a new service each time the page is loaded
as we need to be able to request several times the same image (if we
go to the same page several times during the life of the application),
but its content can change. If we use the same get request each time,
the browser use its cache and show the same contents. By using a
coservice, we can force it to reload the image.

And we finally register the service.

<<code language="ocaml"|let () = My_appl.register ~service:multigraffiti_service
  ( fun name () ->
    (* the page element in wich we will include the canvas *)
    let canvas_box = div [] in
    include_canvas name canvas_box;
    Lwt.return [
      h1 [pcdata name];
      choose_drawing_form ();
      canvas_box;] )
>>

==== {{{Makefile}}} ====

We now need to change the makefile to addapt to these changes. First,
we add the files to the list of files wich need to be compiled. The
order is important, the makefile does not resolve dependencies.
<<code language="Makefile"|
SERVERFILES := common.ml server.ml ${PROJECTNAME}.eliom
CLIENTFILES := common.ml client.ml ${PROJECTNAME}.eliom
>>

Since we are using the deriving syntax in {{{.ml}}} files, we need to
add its package. It was not usefull for compilation of
{{{graffiti.eliom}}} file as the syntax of eliom files depends on the
package {{{ocsigen.deriving.syntax}}}.
<<code language="Makefile"|
SERVERLIB := -package ocsigen.deriving.syntax -package cairo
CLIENTLIB := -package ocsigen.deriving.syntax -package oclosure -package js_of_ocaml.
>>
It is also needed to add {{{-syntax camlp4o \}}} to commands that doesn't have it.

Download the current versions of the files:
<<a_file src="multigraffiti_v1/Makefile" project="tutorial"| Makefile >> 
<<a_file src="multigraffiti_v1/graffiti.eliom" project="tutorial"| graffiti.eliom >> 
<<a_file src="multigraffiti_v1/common.ml" project="tutorial"| common.ml >> 
<<a_file src="multigraffiti_v1/client.ml" project="tutorial"| client.ml >> 
<<a_file src="multigraffiti_v1/server.ml" project="tutorial"| server.ml >> 

=== Cleaning previous pages ===
<<div class="concepts"| Cancel threads and arrows\\ close buses>>

A problem with the current version is that the client keeps receiving
data from pages it leaved.

Add this to {{{client.ml}}}
<<code language="ocaml"|(* type containing all informations we need to stop interraction
   inside the page *)
type drawing_canceller =
    { drawing_thread : unit Lwt.t;
      (* the thread reading messages from the bus *)
      drawing_arrow : Event_arrows.canceller;
      (* the arrow handling mouse events *)
    }

let stop_drawing { drawing_thread; drawing_arrow } =
  Lwt.cancel drawing_thread;
  (* cancelling this thread also close the bus *)
  Event_arrows.cancel drawing_arrow
>>

{{{Lwt.cancel t}}} stops the thread t. In this case it also closes the
  bus on wich t is listeninig. for more informations see
  [[wiki(21):|Lwt programming guide.]] and <<a_api | module Eliom_client_bus >>.

Also replace 
<<code language="ocaml"|  let _ = Lwt_stream.iter (draw ctx) (Eliom_client_bus.stream bus) in
  ignore (run (mousedowns canvas
		 (arr (fun ev -> set_coord ev; line ev)
			      >~>> first [mousemoves Dom_html.document (arr line);
					 mouseup Dom_html.document >~>> (arr line)])) ())
>>
by
<<code language="ocaml"|  let t = Lwt_stream.iter (draw ctx) (Eliom_client_bus.stream bus) in
  let drawing_arrow =
    run (mousedowns canvas
           (arr (fun ev -> set_coord ev; line ev)
			   >~>> first [mousemoves Dom_html.document (arr line);
				      mouseup Dom_html.document >~>> (arr line)])) () in
  { drawing_thread = t;
    drawing_arrow = drawing_arrow }
>>

In {{{graffiti.eliom}}} replace
<<code language="ocaml"|  Eliom_services.onload
    {{
      launch_client_canvas %bus %imageservice %canvas_box
    }}
>>
by
<<code language="ocaml"|  Eliom_services.onload
    {{
      let canceller = launch_client_canvas %bus %imageservice %canvas_box in
      Eliom_client.on_unload (fun () -> stop_drawing canceller; Lwt.return ())
    }}
>>

The function registered by {{{Eliom_client.on_unload}}} will be called
when the page change inside the application.

Download the current versions of the files:
<<a_file src="multigraffiti_v2/graffiti.eliom" project="tutorial"| graffiti.eliom >> 
<<a_file src="multigraffiti_v2/client.ml" project="tutorial"| client.ml >>

===Mixing Eliom client and Eliom server===

We now want to restrict the site to connected users.

From the previous chapter, we copy the code handling users to {{{server.ml}}}:

<<code language="ocaml"|let connection_service =
  Eliom_services.post_coservice' ~post_params:
    (let open Eliom_parameters in (string "name" ** string "password")) ()
let disconnection_service = Eliom_services.post_coservice' ~post_params:Eliom_parameters.unit ()
let create_account_service = 
  Eliom_services.post_coservice ~fallback:main_service ~post_params:
  (let open Eliom_parameters in (string "name" ** string "password")) ()

let username = Eliom_references.eref ~scope:`Session None
let users = ref ["titi","tata";"test","test"]
let check_pwd name pwd = try List.assoc name !users = pwd with Not_found -> false

let () = Eliom_output.Action.register
  ~service:create_account_service
  (fun () (name, pwd) ->
    users := (name, pwd)::!users;
    Lwt.return ())

let () = Eliom_output.Action.register
  ~service:connection_service
  (fun () (name, password) ->
    if check_pwd name password
    then Eliom_references.set username (Some name)
    else Lwt.return ())

let () =
  Eliom_output.Action.register
    ~service:disconnection_service
    (fun () () -> Eliom_state.close_session ())

let disconnect_box () =
  My_appl.post_form disconnection_service
    (fun _ -> [p [My_appl.string_input
                  ~input_type:`Submit ~value:"Log out" ()]]) ()

let login_name_form service button_text =
  My_appl.post_form ~service
    (fun (name1, name2) ->
      [p [pcdata "login: ";
          My_appl.string_input ~input_type:`Text ~name:name1 ();
          br ();
          pcdata "password: ";
          My_appl.string_input ~input_type:`Password ~name:name2 ();
          br ();
          My_appl.string_input ~input_type:`Submit ~value:button_text ()
         ]]) ()
>>

<<div class="wip"| disconnection does not work yet: it also closes the application >>

We make a customized registration module such that disconnected users
(those for which the username reference is not set), are automaticaly
show a connection. That way the other pages can assume that the
username is always available.

<<code language="ocaml"|let default_content () =
  Lwt.return [h1 [pcdata "Welcome to Multigraffiti"];
	      h2 [pcdata "log in"];
	      login_name_form connection_service "Connect";
	      h2 [pcdata "create account"];
	      login_name_form create_account_service "Create account";]

module Connected_translate =
struct
  type page = string -> My_appl.page Lwt.t
  let translate page =
    Eliom_references.get username ~>>=
      function
	| None -> default_content ()
	| Some username -> page username >|= ( fun v -> (disconnect_box ())::v )
end

module Connected =
  Eliom_output.Customize ( My_appl ) ( Connected_translate )

let ( !% ) f = fun a b -> return (fun c -> f a b c)

let () = Connected.register ~service:main_service 
  !% (fun () () username ->
    Lwt.return [h1 [pcdata ("Welcome to Multigraffiti " ^ username)];
		choose_drawing_form ()])
>>

to use that, in {{{graffiti.eliom}}} we just replace

<<code language="ocaml"|let () = My_appl.register ~service:multigraffiti_service
  ( fun name () ->
>>
by
<<code language="ocaml"|let () = Connected.register ~service:multigraffiti_service
  !% ( fun name () username ->
>>

Download the current versions of the files:
<<a_file src="multigraffiti_v3/graffiti.eliom" project="tutorial"| graffiti.eliom >> 
<<a_file src="multigraffiti_v3/server.ml" project="tutorial"| server.ml >>

===Type safe database requests using Macaque===

In this section, we will implement our database access function using
the Macaque library, that allows easy manipulation of Postgresql
database fully compatible with Lwt. ( For more information see
[[wiki(25):| Macaque manual]] )

We will store the login and the password of users in a Postgresql
database. For more information on how to set up and run it, see
[[http://www.postgresql.org/docs/9.0/static/index.html|Postgresql
manual]].

When the base is up and running, we create the base by running is a shell:
<<code language="shell"| $ createdb testbase >>

Then we create the {{{users}}} table, by executing this sql script:

<<code language="sql"| CREATE TABLE users ( 
       login text NOT NULL,
       password text NOT NULL
); >>

We save it under {{{create_table.sql}}} and run

<<code language="shell"| $ psql -d testbase -f create_table.sql >>

We will replace our basic user handling code:

<<code language="ocaml"|let username = Eliom_references.eref ~scope:`Session None
let users = ref ["titi","tata";"test","test"]
let check_pwd name pwd = try List.assoc name !users = pwd with Not_found -> false

let () = Eliom_output.Action.register
  ~service:create_account_service
  (fun () (name, pwd) ->
    users := (name, pwd)::!users;
    Lwt.return ())

let () = Eliom_output.Action.register
  ~service:connection_service
  (fun () (name, password) ->
    if check_pwd name password
    then Eliom_references.set username (Some name)
    else Lwt.return ())
>>

Macaque can use any thread library if it provides a monadic
interface. The default one provides simple blocking access to the
database. It isn't good for us because an access to the base by one
user will prevent the server from handling anything else until the
request is finished. We need a version of Macaque specialised for
Lwt. It is obtained by

<<code language="ocaml"|module Lwt_thread = struct
  include Lwt
  include Lwt_chan
end
module Lwt_PGOCaml = PGOCaml_generic.Make(Lwt_thread)
module Lwt_Query = Query.Make_with_Db(Lwt_thread)(Lwt_PGOCaml)
>>

We can now open the database with our newly created {{{Lwt_PGOCaml.connect}}}.

<<code language="ocaml"|let get_db : unit -> unit Lwt_PGOCaml.t Lwt.t =
  let db_handler = ref None in
  fun () ->
    match !db_handler with
      | Some h -> Lwt.return h
      | None -> Lwt_PGOCaml.connect ~database:"testbase" ()
>>

Then we declare the table on wich we will work and the different
request we do on it.

<<code language="ocaml"|let table = <:table< users (
  login text NOT NULL,
  password text NOT NULL
) ~>>

let find name =
  (get_db () ~>>= fun dbh ->
   Lwt_Query.view dbh
   <:view< {password = row.password} |
            row in $table$;
            row.login = $string:name$; ~>>)

let insert name pwd =
  get_db () ~>>= fun dbh ->
  Lwt_Query.query dbh
  <:insert< $table$ := { login = $string:name$; password = $string:pwd$; } ~>>

let check_pwd name pwd =
  (get_db () ~>>= fun dbh ->
   Lwt_Query.view dbh
   <:view< {password = row.password} |
            row in $table$;
            row.login = $string:name$;
	    row.password = $string:pwd$ ~>>)
  >|= ( function [] -> false | _ -> true )
>>

Finaly, we change a bit the handler of {{{create_account_service}}} to
check for the presence of an account before creating it.

<<code language="ocaml"|let () = Eliom_output.Action.register
  ~service:create_account_service
  (fun () (name, pwd) ->
    find name ~>>=
      (function
	| [] -> insert name pwd
	| _ -> Lwt.return ()) )

let () = Eliom_output.Action.register
  ~service:connection_service
  (fun () (name, password) ->
    check_pwd name password ~>>=
      ( function
	| true -> Eliom_references.set username (Some name)
	| false -> Lwt.return () ) )
>>

We need to add {{{-package macaque.syntax}}} in the makefile and
{{{<extension findlib-package="macaque"/>}}} in graffiti.conf

Download the current versions of the files:
<<a_file src="multigraffiti_macaque/server.ml" project="tutorial"| server.ml >> 
<<a_file src="multigraffiti_macaque/graffiti.conf" project="tutorial"| graffiti.conf >> 
<<a_file src="multigraffiti_macaque/Makefile" project="tutorial"| Makefile >> 
<<a_file src="multigraffiti_macaque/create_table.sql" project="tutorial"| create_table.sql >>

===Saving favorite pictures===
<<div class="concepts"|Persitent tables with Ocsipersist\\
Atom feed>>

We will now add a button to the application to save the current
image. The images will be saved to the filesystem using the module
<<a_api project="lwt" | module Lwt_io>>. We will then make an Atom feed
with the saved images using <<a_api project="eliom" | module Atom_feed >>

We save the images in the directory containing the static contents
under the directory {{{graffiti_saved/username}}}. The {{{username}}}
directory is created if needed. If it already exists {{{mkdir}}} fail
and we do nothing.

<<code language="ocaml"|let static_dir = "/tmp/static/"

let image_dir name =
  let dir = static_dir ^ "/graffiti_saved/" ^ (Ocsigen_lib.encode name) in
  Lwt.catch
    (fun () -> Lwt_unix.mkdir dir 0o777)
    (fun exn -> Lwt.return ())
  >|= (fun () -> dir)

let make_filename name number =
  image_dir name >|= ( fun dir -> (dir ^ "/" ^ (string_of_int number) ^ ".png") )

let save image name number =
  make_filename name number ~>>=
    ( fun file_name ->
      Lwt_io.open_file ~mode:Lwt_io.output file_name ~>>=
	( fun out_chan -> Lwt_io.write out_chan image ) )
>>

We number images and associate to each image the time of creation. It
is stocked in an <<a_api project="eliom" | module Ocsipersist >>
table. These are string indexed tables, that can contain arbitrary
ocaml value.

This open the table and create it if it doesn't exists.
<<code language="ocaml"|let image_info_table = Ocsipersist.open_table "image_info_table">>

For each user, we stock a value of type
{{{ int * CalendarLib.Calendar.t * ( (int * CalendarLib.Calendar.t) list ) }}}.
The first integer is the name under wich will be saved the image, the first time is the last update for that user and the list is the name and time of old images. We need those time to timestamp the entries of the feed.

<<code language="ocaml"|let save_image username =
  let now = CalendarLib.Calendar.now () in
  Lwt.catch
    (fun () -> Ocsipersist.find image_info_table username)
    (function Not_found -> Lwt.return (0,now,[]) | e -> Lwt.fail e )
  ~>>= ( fun (number,_,list) ->
    (Ocsipersist.add image_info_table username (number+1,now,(number,now)::list))
    ~>>= ( fun () ->
      let (_,image_string) = Hashtbl.find graffiti_info username in
      save (image_string ()) username number ))

let save_image_box name =
  let save_image_service =
    Eliom_output.Action.register_post_coservice'
      ~post_params:Eliom_parameters.unit
      (fun () () -> save_image name)
  in
  My_appl.post_form save_image_service
    (fun _ ->
      [p [My_appl.string_input
             ~input_type:`Submit ~value:"save" ()]]) ()
>>

We find the url of the images with << a_api project="eliom" | val
Eliom_services.static_dir >>. It is a service taking file path as
parameter, serving the content of the static directory. We use <<
a_api project="eliom" | val Eliom_uri.make_string_uri >> to get the
url as a string.

<<code language="ocaml"|let feed_service = Eliom_services.service ~path:["feed"]
  ~get_params:(Eliom_parameters.string "name") ()

let local_filename name number =
  ["graffiti_saved"; Ocsigen_lib.encode name ; (string_of_int number) ^ ".png"]

let rec entries name list = function
  | 0 -> []
  | len ->
    match list with
      | [] -> []
      | (n,saved)::q ->
	let title = Atom_feed.plain ("graffiti " ^ name ^ " " ^ (string_of_int n)) in
	let uri = 
	  Eliom_uri.make_string_uri ~absolute:true ~service:(Eliom_services.static_dir ())
	    (local_filename name n)
	in
	let entry =
	  Atom_feed.entry ~title ~id:uri ~updated:saved
            [Atom_feed.xhtmlC [ XHTML.M.img ~src:uri ~alt:"image" ()]] in
	entry::(entries name q (len - 1))

let feed name () =
  let id = Eliom_uri.make_string_uri ~absolute:true ~service:feed_service name in
  let title = Atom_feed.plain ("nice drawings of " ^ name) in
  Lwt.catch
    (fun () -> Ocsipersist.find image_info_table name >|=
	(fun (number,updated,list) -> Atom_feed.feed ~id ~updated ~title (entries name list 10)))
    ( function Not_found ->
      let now = CalendarLib.Calendar.now () in
      Lwt.return (Atom_feed.feed ~id ~updated:now ~title [])
      | e -> Lwt.fail e )

let () = Eliom_atom.Reg.register ~service:feed_service feed
>>


In {{{graffiti.eliom}}}, we add a link to the feed and a save button
that appear only if the user own the page.

<<code language="ocaml"|      My_appl.a feed_service [pcdata "atom feed"] name;
      div ( if name = username
	then [save_image_box name]
	else [pcdata "no saving"] );
>>

Before running, add the {{{graffiti_saved}}} directory in your
directory containing static contents and edit {{{let static_dir =
"/tmp/static/"}}} to addapt to your configuration.

Download the current versions of the files:
<<a_file src="multigraffiti_atom/server.ml" project="tutorial"| server.ml >> 
<<a_file src="multigraffiti_atom/graffiti.eliom" project="tutorial"| graffiti.eliom >>

<<div class="encadre"|====  ====
>>

===Connection with external accounts===
<<div class="concepts"|openID>>
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>

===listening music===
<<div class="concepts"|Persistence of the client application>>

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>


===???===
<<div class="concepts"|Other features: Client side service calls ...\\
Client side forms ...\\
**LWT** -> oÃ¹ ????????????,>>
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>
