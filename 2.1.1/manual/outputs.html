<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title> Writing service handlers</title><meta charset="utf8"/><link rel="stylesheet" href="/home/balat/ocsigen/ocsigen.github.io/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="/home/balat/ocsigen/html_of_wiki/client.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script></head><body><div class="project-page project-eliom"><div class="page-header"><p class="logo-ocsigen"><a href="/" class="ocsimore_phrasing_link"><img src="/img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><ul><li><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="mainmenu-current"><a href="/eliom/6.2/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/2.8.4/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/ocsigenserver/2.8/manual/quickstart" class="ocsimore_phrasing_link">Server</a>
</li><li><a href="/lwt/3.1.0/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-toolkit/1.0/manual/intro" class="ocsimore_phrasing_link">Toolkit</a>
</li><li><a href="/ocsigen-start/1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li><li><a href="/projects" class="ocsimore_phrasing_link">Other projects</a></li></ul></div><div class="version-selector"><p>Version
</p><div class="version-selector-versions"><p><span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/manual/intro">6.2</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.1/manual/intro">6.1</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.0/manual/intro">6.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/5.0/manual/intro">5.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/4.2/manual/intro">4.2</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/4.1/manual/intro">4.1</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/4.0/manual/intro">4.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/3.0/manual/intro">3.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.2.2/manual/intro">2.2.2</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/intro">2.1.1</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.0.2/manual/intro">2.0.2</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.0.1/manual/intro">2.0.1</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.0/manual/intro">2.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/1.3.4/manual/intro">1.3.4</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/1.2.2/manual/intro">1.2.2</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/1.1.0/manual/intro">1.1.0</a></span>
<span><a class="ocsforge_doclink_eliom" href="/eliom/dev/manual/intro">dev</a></span></p></div></div><button id="reason">Switch to </button><form id="search"><input name="q" id="q" placeholder="search ..."/><button>Search</button></form><h1> Writing service handlers</h1><nav id="overview" class="ocsimore_outline"><header><h1>Table of contents</h1></header></nav><script>
//<![CDATA[
outline([0,-515484383,0,[0,2],[0,"nav",[0,"aside",0]],"overview",0])
//]]>
</script><div class="paragraph"><p>Many kind of outputs modules</p></div><p>Once the <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#classification">service identification mechanism</a></span> identified the service responsible
for a given URL it executes its service handler. The service handler
is a function taking the GET and POST parameters as argument and
returning the content to be sent to the client. The return type of the
service handler depends on the function used to register it. On the
most common case its HTML5 contents build with the TyXML library, but
Eliom provides a lot of outputs modules to ease the implementation of
common web interaction. See section <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/outputs#predefined_outputs">Predefined output modules </a></span> for a
comprehensive list.
</p><div class="paragraph"><p>Cooperative service handler</p></div><p>As Ocsigenserver, Eliom is based on cooperative threading library and
service handler must written your in a cooperative way. See section
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/outputs#lwt">Writing cooperative
service handlers with Lwt </a></span> for some examples.
</p><div class="paragraph"><p>Error handling</p></div><p>See section <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/outputs#error_handling">Error handling</a></span>.
</p><h2 id="predefined_outputs"> Predefined output modules <a class="backref" href="#predefined_outputs">&#182;</a></h2><h3> List of predefined output modules</h3><aside class="wip"><header><h5>Work in progress</h5></header><p>Add types and options for each module?</p></aside><p>Services can send several types of data, using a variety of predefined modules.
It is also possible to <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/outputs#creating">create your own output modules</a></span>.
The main predefined output modules are:
</p><div class="paragraph"><p>Generating content for the browser</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Html5">Eliom_registration.​Html5</a></span> (and <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Xhtml">Eliom_registration.​Xhtml</a></span>)
</dt><dd> Allows to register functions that generate html5 pages statically checked
using polymorphic variant types. You may use constructor functions from <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_content.Html5.D">Eliom_content.​Html5.​D</a></span> (resp <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_content.Xhtml.D">Eliom_content.​Xhtml.​D</a></span>) or a syntax extension close to the standard html syntax.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Flow5">Eliom_registration.​Flow5</a></span> (and <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Block">Eliom_registration.​Block</a></span>)
</dt><dd> Allows to register functions that generate a portion of page using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_content.Html5.F">Eliom_content.​Html5.​F</a></span> (resp <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_content.Xhtml.F">Eliom_content.​Xhtml.​F</a></span>) or the syntax extension. (useful for <span class="code">XMLHttpRequest</span> requests for example). Do not use with Eliom application: use <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Ocaml">Eliom_registration.​Ocaml</a></span> instead.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_duce.Xhtml">Eliom_duce.​Xhtml</a></span>
</dt><dd> Allows to register functions that generate XHTML 1.1 pages   statically checked using <span class="code">OCamlduce</span>. Typing is   stricter, and you need a modified version of the OCaml compiler   (OCamlduce).
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.HtmlText">Eliom_registration.​HtmlText</a></span>
</dt><dd> Allows to register functions that   generate text html pages, without any typechecking of the content. The content type sent by the server is &quot;text/html&quot;.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.CssText">Eliom_registration.​CssText</a></span>
</dt><dd> Allows to register functions that   generate CSS pages, without any typechecking of the content. The content type sent by the server is &quot;<span class="teletype">text/css</span>&quot;.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.String">Eliom_registration.​String</a></span>
</dt><dd> Allows to register functions that   generate text pages, without any typechecking of the content. The services return a pair of strings. The first one is the content   of the page, the second one is the content type.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.File">Eliom_registration.​File</a></span>
</dt><dd> Allows to register services that send files. See <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#eliomfiles">here</a></span> for an example of use.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Streamlist">Eliom_registration.​Streamlist</a></span>
</dt><dd> Allows to register services that send &quot;byte&quot; contents. It is used when big contents (that does not fit in memory) is generated.
</dd></dl><div class="paragraph"><p>Generating content for client-server applications</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.App">Eliom_registration.​App</a></span>
</dt><dd> is a functor that generates a module allowing to create services belonging to a client-server Eliom application (see <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/client">chapter client-server applications</a></span>)
</dd></dl><div class="paragraph"><p>Special browser interraction</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Action">Eliom_registration.​Action</a></span>
</dt><dd> Allows to register actions (functions that do not generate any page, see <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#actions">Action</a></span>). The page corresponding to the URL (without the coservice parameter that triggered the action) is reloaded after the action by default if possible.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Unit">Eliom_registration.​Unit</a></span>
</dt><dd> is like <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Action">Eliom_registration.​Action</a></span> but the URL is not reloaded after the action. (Same as <span class="teletype">Eliom_registration.Action</span> with <span class="teletype">[`NoReload]</span> option).
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Redirection">Eliom_registration.​Redirection</a></span>
</dt><dd> Allows to register HTTP redirections. The handler returns the service (without parameter) of the page you want to redirect to. The browser will get a 301 or 307 code in answer and redo the request to the new URL. To specify whether you want temporary (307) or permanent (301) redirections, use the <span class="code">?options</span> parameter of registration functions. For example: <span class="code">register options:`Permanent ...</span> or <span class="code">register options:`Temporary ...</span>.
</dd><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.String_redirection">Eliom_registration.​String_redirection</a></span>
</dt><dd> Same but the ouput type is a string. Use with care! Warning: According to the RFC of the HTTP protocol, the URL must be absolute!
</dd></dl><div class="paragraph"><p>Customization of other outputs</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Customize">Eliom_registration.​Customize</a></span>
</dt><dd> Allows to specialize service registration functions by customizing the page type.
</dd></dl><div class="paragraph"><p>Sending caml values to client side code</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Ocaml">Eliom_registration.​Ocaml</a></span>
</dt><dd> allows to register services sending marshalled OCaml values. See the section on
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/client#communication">communications in the chapter about client-server applications</a></span>
</dd></dl><div class="paragraph"><p>Runtime choice of content</p></div><dl><dt><span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span>
</dt><dd> Allows to register services that can choose what they send, for example an xhtml page or a file, depending on some situation (parameter, user logged or not, page present in a cache ...). It is also possible to create your own modules for other types of pages. See <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#any">here</a></span> for an example of use.
</dd></dl><h3> Specific output modules</h3><nav id="overview" class="ocsimore_outline"></nav><script>
//<![CDATA[
outline([0,-515484383,0,[0,2],[0,"nav",[0,"aside",0]],"overview",0])
//]]>
</script><h4 id="eliomfiles"> Sending files  <a class="backref" href="#eliomfiles">&#182;</a></h4><p>You may want to register a service that will send files.  To do that,
use the <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.File">Eliom_registration.​File</a></span> module. Example:
</p><pre class=""><code class="language-ocaml translatable">let sendfile =
  File.register_service
    ~path:[&quot;sendfile&quot;]
    ~get_params:unit
    (fun () () -&gt; return &quot;filename&quot;)</code></pre><p>Other example, with &quot;suffix&quot; services (see <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/params#suffix">here</a></span>):
</p><pre class=""><code class="language-ocaml translatable">let sendfile2 =
  File.register_service
    ~path:[&quot;files&quot;]
    ~get_params:(suffix (all_suffix &quot;filename&quot;))
    (fun s () -&gt;
      return (&quot;//path//&quot;^(Ocsigen_lib.string_of_url_path ~encode:false s)))</code></pre><p>The extension <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#staticparts">Staticmod</a></span> is another way to
handle static files.
</p><h4>Sending portions of pages</h4><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Flow5">Eliom_registration.​Flow5</a></span> and <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Block">Eliom_registration.​Block</a></span> modules allow you to register services that send portions of pages, of any &quot;block&quot; type for Html5.F (resp. Xhtml.F).
It is sometimes useful to create AJAX pages
(i.e. pages using the <span class="code">XMLHttpRequest</span> Javascript object).
Note that the service returns a list of blocks. For sending HTML
to client side eliom application, <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Ocaml">Eliom_registration.​Ocaml</a></span> is better
suited.
</p><pre class=""><code class="language-ocaml translatable">let divpage =
  Eliom_registration.Block.register_service
    ~path:[&quot;div&quot;]
    ~get_params:unit
    (fun () () -&gt;
      Lwt.return
        [div [h2 [pcdata &quot;Hallo&quot;];
              p [pcdata &quot;Blablablabla&quot;] ]])</code></pre><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Make_typed_xml_registration">Eliom_registration.​Make_typed_xml_registration</a></span> module
allows to create other modules for registering portions of pages of
other types.  For example, <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Flow5">Eliom_registration.​Flow5</a></span> is
defined by:
</p><pre class=""><code class="language-ocaml translatable">module Flow5 = Make_typed_xml_registration(Xml)(Html5.F)(struct
  type content = Html5_types.body_content
end)</code></pre><h4 id="redirections">Redirections <a class="backref" href="#redirections">&#182;</a></h4><h5> Redirections to eliom services</h5><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Redirection">Eliom_registration.​Redirection</a></span> module allows you to register HTTP redirections.<br/>
If a request is made for such a service, the server asks the browser
to retry with another URL.
</p><p>Such services return a GET service without parameter at all.
Example:
</p><pre class=""><code class="language-ocaml translatable">let redir1 = Eliom_registration.Redirection.register_service
    ~options:`Temporary
    ~path:[&quot;redir&quot;]
    ~get_params:Eliom_parameter.unit
   (fun () () -&gt; Lwt.return coucou)</code></pre><p>If you want to give parameters to such services, use
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_service#VALpreapply">Eliom_service.​preapply</a></span> (see also in
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#preapplied">section about pre-applied services</a></span>).
Example:
</p><pre class=""><code class="language-ocaml translatable">let redir = Eliom_registration.Redirection.register_service
   ~options:`Temporary
   ~path:[&quot;redir&quot;]
   ~get_params:(int &quot;o&quot;)
   (fun o () -&gt;
      Lwt.return
        (Eliom_service.preapply coucou_params (o,(22,&quot;ee&quot;))))</code></pre><p>The <span class="code">options</span> parameter may be either
<span class="code">`Temporary</span> or <span class="code">`Permanent</span>.
</p><p>Note that the cost of a redirection is one more request and
one more response.
</p><h5> Redirections to generated urls</h5><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.String_redirection">Eliom_registration.​String_redirection</a></span> allows you to
register HTTP redirections to generated URLs. Usualy, prefer <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.String_redirection">Eliom_registration.​String_redirection</a></span>, even for external
redirections (using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_service#VALexternal_service">Eliom_service.​external_service</a></span>).
Use <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.String_redirection">Eliom_registration.​String_redirection</a></span> only when it is
not possible to have a service corresponding to an URL.
</p><p>Notice that the supplied URL must be absolute.
</p><h4 id="actions">Actions <a class="backref" href="#actions">&#182;</a></h4><p>Actions are used to perform sides effects before generating the
fallback of a service. When an action is called, the service handler is
executed, then the service handler of the fallback service is
executed.
</p><p>Eliom references of scope <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_common#VALrequest">Eliom_common.​request</a></span> set in
an action handler are still available in the service handler of the fallback.
</p><aside class="wip"><header><h5>Work in progress</h5></header><p>for Vincent</p></aside><p>services that do not generate any page.
Use them to perform an effect on the server (connection/disconnection
of a user, adding something in a shopping basket, deleting a message in
a forum, etc.).
</p><p>By default, the page you link to is displayed after the action.  For
example, when you have the same form (or link) on several pages (e.g.
a connection form), instead of making a version with post params of
all these pages, you can use a single action, registered on a
<span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services">non-attached coservice</a></span>.
</p><p>See more details and an example in the section about non-attached coservices
below, or in section * * connection-of-user.
</p><p>The return type of action handlers is
<span class="code">unit Lwt.t</span>.
We will see <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/manual/services#infofallbacks">later</a></span> how to transmit information
to the service that will take charge of the generation of the page.<br/>
</p><p>A common use of actions and non-attached coservices working together
is the implementation of login/logout forms.
An example is given in the chapter about the server-side state
of the application (section sec-state-connect).
In that example, actions and non-attached coservices make staightforward
the implementation of the behaviour you generally want for such features:
</p><ul><li> Connection and disconnection stay on the same page,
</li><li> If you want a connection/disconnection form on each page, no need
to create a version with POST parameters of each service.
</li></ul><p>The implementation of the same behaviour with usual Web programming techniques
is usually much more complicated.
</p><h4 id="any"> Registering services that decide what they want to send  <a class="backref" href="#any">&#182;</a></h4><p>You may want to register a service that will send, for instance,
sometimes an XHTML page, sometimes a file, sometimes something else.
To do that, use the <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span> module,
together with the <span class="code">send</span> function of the module
you want to use. Example:
</p><pre class=""><code class="language-ocaml translatable">let send_any =
  Eliom_registration.Any.register_service
    ~path:[&quot;sendany&quot;]
    ~get_params:(string &quot;type&quot;)
   (fun s () -&gt;
     if s = &quot;valid&quot;
     then
       Eliom_registration.Html5.send
         (html
            (head (title (pcdata &quot;&quot;)) [])
            (body [p [pcdata
                        &quot;This page has been statically typechecked.
                         If you change the parameter in the URL you will
                         get an unchecked text page&quot;]]))
     else
       Eliom_registration.HtmlText.send
         &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;It is not a valid page. Put type=\&quot;valid\&quot; in the
          URL to get a typechecked page.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;
   )</code></pre><h5> Dynamicaly modifying register options using Any</h5><p>You may also use <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span> to dynamicaly
modify the parameters usualy set on the register function. You can set
the HTTP code, the charset, the content_type, the http headers and the
specific option of the output module.
</p><pre class=""><code class="language-ocaml translatable">let change_option =
  Eliom_registration.Any.register_service
    ~path:[&quot;change_option&quot;]
    ~get_params:(unit)
   (fun () () -&gt;
     Eliom_registration.Html5.send
       ~code:403
       (html
          (head (title (pcdata &quot;forbidden&quot;)) [])
          (body [p [pcdata &quot;forbidden&quot;]])))</code></pre><h5> About Kind type and how to serve application and other content with the same service</h5><p>In Eliom application, changing the current page does not do always the
same thing. When going to a page inside the same application by
clicking a link (or calling <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/client/Eliom_client#VALchange_page">Eliom_client.​change_page</a></span>) the client
application perform a XmlHttpRequest and modify the displayed page
according to the result. When going to content outside the
application (an other site, a static file, etc.) the client leaves the
application by changing the browser url.
</p><p>When using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span>, there is no way to
know before the request wether the content is from the same
application or not. To that end there are phantom type annotations to
the type of the <span class="teletype">send</span> functions: <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration#TYPEkind">Eliom_registration.​kind</a></span>. The <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Any#VALregister">Eliom_registration.​Any.​register</a></span>
takes a service handler that can server only one kind of content: that
way it is not possible to inadvertantly mix kinds. The different kinds
of content are:
</p><ul><li> Browser content: everything that can't be handled by application
directly: ex Html pages, files
</li><li> Block content: subparts of pages sent as XML: ex Flow5, Block.
</li><li> Application content: pages of application.
</li><li> Ocaml content: marshalled OCaml values.
</li><li> Unknown content: content generated as text.
</li></ul><p>Yet sometimes you can want to mix the kinds of contents a service can
return. The function <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration#VALappl_self_redirect">Eliom_registration.​appl_self_redirect</a></span>
allows to cast browser content to application content. When an
application request some content casted througt that function the
server send some informations telling the client to exit to that
address instead. You should not use that on POST services: Leaving the
application sending POST parameters is not always possible and the
request will be performed 2 times.
</p><p>For instance if you want to serve files if they exists and generate
some error message with client side code otherwise, you should do
something like that.
</p><pre class=""><code class="language-ocaml translatable">let file_or_application =
  Eliom_registration.Any.register_service
    ~path:[&quot;file_or_application&quot;]
    ~get_params:(string &quot;filename&quot;)
   (fun filename () -&gt;
     if Eliom_registration.File.check_file filename
     then
       Eliom_registration.appl_self_redirect Eliom_registration.File.send filename
     else
       My_application.send ~code:404
         (html
           (head (title (pcdata &quot;no page&quot;)) [])
           (body [p ~a:[a_onclick {{ do some client action }}]
	     [pcdata &quot;the file does not exist&quot;]])))</code></pre><p>Unknown content can be casted to browser content using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration#VALcast_unknown_content_kind">Eliom_registration.​cast_unknown_content_kind</a></span>.
</p><h3 id="creating">Creating your own output modules <a class="backref" href="#creating">&#182;</a></h3><h4 id="customize">By customizing an existing registration module <a class="backref" href="#customize">&#182;</a></h4><p>Using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration.Customize">Eliom_registration.​Customize</a></span> you can specialise a
registration function to avoid code duplication. You can for instance
for each service add parameters before calling the service handler, or
modify the answer.
</p><p>A classical use is to check wether a user is logged in before serving
the content of a page. That way, we don't need to do the check in
every service handler and we can get directly the user informations.
</p><p>In this example, we check if we are in a session group telling that
the user is connected. If it not the case, we generate a login
page. When we are in a group, we retrieve the user informations and
pass it to the service handler. It returns a title and the content of
the body. That way, it also always generate the same css without code
duplication.
</p><pre class=""><code class="language-ocaml translatable">module Connected_param =
struct
  type page = user_informations -&gt; Eliom_registration.Html5.page Lwt.t
  let translate page =
    match Eliom_state.get_volatile_data_session_group
      ~scope:Eliom_common.session () with
	| None -&gt; login_page ()
	| Some group_name -&gt;
	  lwt user_info = get_user_info group_name in
	  lwt (page_title,content) = page user_info in
	  return (html (head (title (pcdata page_title))
	                 [ Some css and things like that ])
	               (body content))
end

module Connected =
  Eliom_registration.Customize ( Eliom_registration.Html5 ) ( Connected_param )</code></pre><h4> By building the HTTP frame</h4><p>When you need to declare some kind of specific service, you may need
to create your own registration module: For instance here we define a
module serving integers as text. Notice that in that case you can and
should use customize instead.
</p><p>For that you need to use the <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_mkreg.MakeRegister">Eliom_mkreg.​MakeRegister</a></span> functor.
</p><pre class=""><code class="language-ocaml translatable">module Int_reg_base = struct

  type page = int

  type options = unit

  type return = http_service

  type result = (browser_content, http_service) kind

  let result_of_http_result = Eliom_registration.cast_http_result

  let send_appl_content = Eliom_service.XNever

  let send ?options ?charset ?code ?content_type ?headers content =
    let content = string_of_int content in
    lwt r = Ocsigen_senders.Text_content.result_of_content content in
    Lwt.return
      { r with
        Ocsigen_http_frame.
        res_code    = code_of_code_option code;
        res_charset = (match charset with
          | None -&gt;  Some (Eliom_config.get_config_default_charset ())
          | _ -&gt; charset);
        res_content_type = (match content_type with
          | None -&gt; r.Ocsigen_http_frame.res_content_type
          | _ -&gt; content_type
        );
        res_headers = (match headers with
          | None -&gt; r.Ocsigen_http_frame.res_headers
          | Some headers -&gt;
            Http_headers.with_defaults headers r.Ocsigen_http_frame.res_headers
        );
      }

end

module Int = Eliom_mkreg.MakeRegister(Int_reg_base)</code></pre><p>If your <span class="teletype">page</span> type has parameters you should use <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_mkreg.MakeRegister_AlphaReturn">Eliom_mkreg.​MakeRegister_AlphaReturn</a></span> instead.
</p><h2 id="lwt"> Writing cooperative service handlers with Lwt  <a class="backref" href="#lwt">&#182;</a></h2><p>Remember that a Web site written with Eliom is an OCaml application.
This application must be able to handle several requests at the same
time, in order to prevent a single request from making the whole
server hang.  To make this possible, Ocsigen uses <em>cooperative
threads</em> (implemented in monadic style) which make them really easy
to use (see <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt">Lwt</a></span> module).
</p><p>Below is an example of a page written in a non-cooperative way, that
has the effect of stopping the entire server for 5 seconds. No one
will be able to query the server during this period:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
let looong =
  Eliom_registration.Html5.register_service
    ~path:[&quot;looong&quot;]
    ~get_params:unit
    (fun () () -&gt;
       Unix.sleep 5;
       Lwt.return
         Html5.D.(html
                    (head (title (pcdata &quot;&quot;)) [])
                    (body [h1 [pcdata &quot;Ok now, you can read the page.&quot;]])))</code></pre><p>To solve this problem, use a cooperative version of <span class="teletype">Unix.sleep</span>:
<span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_unix#VALsleep">Lwt_unix.​sleep</a></span>:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
let looong =
  Eliom_registration.Html5.register_service
    ~path:[&quot;looong&quot;]
    ~get_params:unit
    (fun () () -&gt;
       Lwt_unix.sleep 5.0 ~&gt;&gt;= fun () -&gt;
       Lwt.return
         Html5.D.(html
                   (head (title (pcdata &quot;&quot;)) [])
                   (body [h1 [pcdata &quot;Ok now, you can read the page.&quot;]])))</code></pre><p>If you want to use, say, a database library that is not written
in a cooperative way, but is thread-safe for preemptive threads,
use the <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_preemptive">Lwt_preemptive</a></span> module to
detach the computation. In the following example,
we simulate the request by making a call to <span class="code">Unix.sleep</span>:
</p><pre class=""><code class="language-ocaml translatable">let looong2 =
  register_service
    ~path:[&quot;looong2&quot;]
    ~get_params:unit
    (fun () () -&gt;
       Lwt_preemptive.detach Unix.sleep 5 ~&gt;&gt;= fun () -&gt;
       Lwt.return
         (html
           (head (title (pcdata &quot;&quot;)) [])
           (body [h1 [pcdata &quot;Ok now, you can read the page.&quot;]])))</code></pre><h2 id="error_handling"> Error handling  <a class="backref" href="#error_handling">&#182;</a></h2><h3> Exception handling</h3><p>You can catch the exceptions raised during page generation in two places:
</p><ul><li> add an exception handler to services using the <span class="teletype">?error_handler</span>
parameter of the registration functions.
</li><li> add a global exception handler using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_registration#VALset_exn_handler">Eliom_registration.​set_exn_handler</a></span>
</li></ul><p>You can use it to catch exception <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_common#EXCEPTIONEliom_404">Eliom_common.​Eliom_404</a></span> and generate a custom 404 page.
</p><pre class=""><code class="language-ocaml translatable">let _ = Eliom_registration.set_exn_handler
   (fun e -&gt; match e with
    | Eliom_common.Eliom_404 -&gt;
        Eliom_registration.Html5.send ~code:404
          (html
             (head (title (pcdata &quot;&quot;)) [])
             (body [h1 [pcdata &quot;Eliom tutorial&quot;];
                    p [pcdata &quot;Page not found&quot;]]))
    | Eliom_common.Eliom_Wrong_parameter -&gt;
        Eliom_registration.Html5.send
          (html
             (head (title (pcdata &quot;&quot;)) [])
             (body [h1 [pcdata &quot;Eliom tutorial&quot;];
                    p [pcdata &quot;Wrong parameters&quot;]]))
    | e -&gt; fail e)</code></pre><h3 id="infofallbacks"> Fallback services <a class="backref" href="#infofallbacks">&#182;</a></h3><p>You can check wether a service was directly called or if it was used
as a fallback using the <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_request_info#VALget_link_too_old">Eliom_request_info.​get_link_too_old</a></span> function. In case of coservices
registered with a restricted scope, you can check which state was
closed using <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_request_info#VALget_expired_service_sessions">Eliom_request_info.​get_expired_service_sessions</a></span>
</p><h3> Error in services handlers of actions</h3><p>If something wrong happens during an action, it is possible to inform
the service generating the page. For instance if you want to display a
&quot;wrong password&quot; message after an aborted connection.  To transmit
that kind of information, use eliom references (see module <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_reference">Eliom_reference</a></span>) created using scope <span><a class="ocsforge_doclink_eliom" href="/eliom/2.1.1/api/server/Eliom_common#VALrequest">Eliom_common.​request</a></span>, the value will be available to the service
generating the page.
</p><p>Other examples: if you create user accounts using actions. if the
creation fails you may want to display some message to the user, like
&quot;password too weak&quot; or &quot;name already used&quot;.
</p></div></body></html>
